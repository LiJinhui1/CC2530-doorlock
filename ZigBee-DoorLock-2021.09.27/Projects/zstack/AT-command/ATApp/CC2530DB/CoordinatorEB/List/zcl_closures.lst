###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Nov/2021  10:55:03
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Components\stack\zcl\zcl_closures.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWCCF6.tmp
#        (F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Components\stack\zcl\zcl_closures.c
#        -D ZIGBEEPRO -D INTER_PAN -D DISABLE_GREENPOWER_BASIC_PROXY -D
#        HAL_UART=TRUE -D HAL_UART_ISR=1 -D HAL_UART_DMA=0 -D
#        HAL_UART_ISR_RX_MAX=100 -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D
#        NV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D
#        xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D LEGACY_LCD_DEBUG
#        -D LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_WRITE -D ZCL_DISCOVER -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_SCENES
#        -D ZCL_GROUPS -D ZCL_REPORT_CONFIGURING_DEVICE -D
#        ZCL_REPORT_DESTINATION_DEVICE -lC
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\CoordinatorEB\List
#        -lA
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\CoordinatorEB\List
#        --diag_suppress Pe001,Pa010 -o
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\CoordinatorEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=10 -DMAX_RTG_ENTRIES=15 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=300
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000) -f
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\ZCL\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\UserAPI\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\Controller\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\bdb\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\gp\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\zcl\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\CoordinatorEB\List\zcl_closures.lst
#    Object file        =  
#        F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\CoordinatorEB\Obj\zcl_closures.r51
#
###############################################################################

F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Components\stack\zcl\zcl_closures.c
      1          /**************************************************************************************************
      2            Filename:       zcl_closures.c
      3            Revised:        $Date: 2013-10-16 16:38:58 -0700 (Wed, 16 Oct 2013) $
      4            Revision:       $Revision: 35701 $
      5          
      6            Description:    Zigbee Cluster Library - Closures.
      7          
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "zcl.h"
     45          #include "zcl_general.h"
     46          #include "zcl_closures.h"
     47          #include "zcl_doorlock.h"
     48          #include "AT_doorlock.h"

  ZStatus_t AT_DoorLock_Unlock( zclDoorLock_t *pInCmd );
                                ^
"F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\Source\Controller\AT_doorlock.h",97  Error[Pe020]: 
          identifier "zclDoorLock_t" is undefined

  ZStatus_t AT_DoorLock_Lock( zclDoorLock_t *pInCmd );
                              ^
"F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\Source\Controller\AT_doorlock.h",98  Error[Pe020]: 
          identifier "zclDoorLock_t" is undefined

  ZStatus_t AT_DoorLock_SetTemporaryPin_Req( zclDoorLockSetTemporaryPin_t *pCmd );
                                             ^
"F:\2workspace\doorlock-CC2530\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\Source\Controller\AT_doorlock.h",99  Error[Pe020]: 
          identifier "zclDoorLockSetTemporaryPin_t" is undefined
     49          
     50          #if defined ( INTER_PAN )
     51            #include "stub_aps.h"
     52          #endif
     53          
     54          /*********************************************************************
     55           * MACROS
     56           */
     57          
     58          /*********************************************************************
     59           * CONSTANTS
     60           */
     61          
     62          /*********************************************************************
     63           * TYPEDEFS
     64           */
     65          #ifdef ZCL_DOORLOCK
     66          typedef struct zclClosuresDoorLockCBRec
     67          {
     68            struct zclClosuresDoorLockCBRec     *next;
     69            uint8                                endpoint; // Used to link it into the endpoint descriptor
     70            zclClosures_DoorLockAppCallbacks_t  *CBs;     // Pointer to Callback function
     71          } zclClosuresDoorLockCBRec_t;
     72          #endif
     73          
     74          #ifdef ZCL_WINDOWCOVERING
     75          typedef struct zclClosuresWindowCoveringCBRec
     76          {
     77            struct zclClosuresWindowCoveringCBRec     *next;
     78            uint8                                     endpoint; // Used to link it into the endpoint descriptor
     79            zclClosures_WindowCoveringAppCallbacks_t  *CBs;     // Pointer to Callback function
     80          } zclClosuresWindowCoveringCBRec_t;
     81          #endif
     82          
     83          /*********************************************************************
     84           * GLOBAL VARIABLES
     85           */
     86          
     87          /*********************************************************************
     88           * GLOBAL FUNCTIONS
     89           */
     90          
     91          /*********************************************************************
     92           * LOCAL VARIABLES
     93           */
     94          #ifdef ZCL_DOORLOCK
     95          static zclClosuresDoorLockCBRec_t *zclClosuresDoorLockCBs = (zclClosuresDoorLockCBRec_t *)NULL;
     96          #endif
     97          
     98          #ifdef ZCL_WINDOWCOVERING
     99          static zclClosuresWindowCoveringCBRec_t *zclClosuresWindowCoveringCBs = (zclClosuresWindowCoveringCBRec_t *)NULL;
    100          #endif
    101          
    102          #ifdef ZCL_DOORLOCK
    103          static uint8 zclDoorLockPluginRegisted = FALSE;
    104          #endif
    105          
    106          #ifdef ZCL_WINDOWCOVERING
    107          static uint8 zclWindowCoveringPluginRegisted = FALSE;
    108          #endif
    109          
    110          /*********************************************************************
    111           * LOCAL FUNCTIONS
    112           */
    113          #if defined(ZCL_DOORLOCK) || defined(ZCL_WINDOWCOVERING)
    114          static ZStatus_t zclClosures_HdlIncoming( zclIncoming_t *pInMsg );
    115          static ZStatus_t zclClosures_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    116          #endif
    117          
    118          #ifdef ZCL_DOORLOCK
    119          static zclClosures_DoorLockAppCallbacks_t *zclClosures_FindDoorLockCallbacks( uint8 endpoint );
    120          static ZStatus_t zclClosures_ProcessInDoorLockCmds( zclIncoming_t *pInMsg,
    121                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
    122          static ZStatus_t zclClosures_ProcessInDoorLock( zclIncoming_t *pInMsg,
    123                                                          zclClosures_DoorLockAppCallbacks_t *pCBs );
    124          #ifdef ZCL_DOORLOCK_EXT
    125          static ZStatus_t zclClosures_ProcessInDoorLockUnlockWithTimeout( zclIncoming_t *pInMsg,
    126                                                                           zclClosures_DoorLockAppCallbacks_t *pCBs );
    127          static ZStatus_t zclClosures_ProcessInDoorLockGetLogRecord( zclIncoming_t *pInMsg,
    128                                                                      zclClosures_DoorLockAppCallbacks_t *pCBs );
    129          static ZStatus_t zclClosures_ProcessInDoorLockSetPINCode( zclIncoming_t *pInMsg,
    130                                                                    zclClosures_DoorLockAppCallbacks_t *pCBs );
    131          static ZStatus_t zclClosures_ProcessInDoorLockGetPINCode( zclIncoming_t *pInMsg,
    132                                                                    zclClosures_DoorLockAppCallbacks_t *pCBs );
    133          static ZStatus_t zclClosures_ProcessInDoorLockClearPINCode( zclIncoming_t *pInMsg,
    134                                                                      zclClosures_DoorLockAppCallbacks_t *pCBs );
    135          static ZStatus_t zclClosures_ProcessInDoorLockClearAllPINCodes( zclIncoming_t *pInMsg,
    136                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs );
    137          static ZStatus_t zclClosures_ProcessInDoorLockSetUserStatus( zclIncoming_t *pInMsg,
    138                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs );
    139          static ZStatus_t zclClosures_ProcessInDoorLockGetUserStatus( zclIncoming_t *pInMsg,
    140                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs );
    141          static ZStatus_t zclClosures_ProcessInDoorLockSetWeekDaySchedule( zclIncoming_t *pInMsg,
    142                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs );
    143          static ZStatus_t zclClosures_ProcessInDoorLockGetWeekDaySchedule( zclIncoming_t *pInMsg,
    144                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs );
    145          static ZStatus_t zclClosures_ProcessInDoorLockClearWeekDaySchedule( zclIncoming_t *pInMsg,
    146                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
    147          static ZStatus_t zclClosures_ProcessInDoorLockSetYearDaySchedule( zclIncoming_t *pInMsg,
    148                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs );
    149          static ZStatus_t zclClosures_ProcessInDoorLockGetYearDaySchedule( zclIncoming_t *pInMsg,
    150                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs );
    151          static ZStatus_t zclClosures_ProcessInDoorLockClearYearDaySchedule( zclIncoming_t *pInMsg,
    152                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
    153          static ZStatus_t zclClosures_ProcessInDoorLockSetHolidaySchedule( zclIncoming_t *pInMsg,
    154                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs );
    155          static ZStatus_t zclClosures_ProcessInDoorLockGetHolidaySchedule( zclIncoming_t *pInMsg,
    156                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs );
    157          static ZStatus_t zclClosures_ProcessInDoorLockClearHolidaySchedule( zclIncoming_t *pInMsg,
    158                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
    159          static ZStatus_t zclClosures_ProcessInDoorLockSetUserType( zclIncoming_t *pInMsg,
    160                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs );
    161          static ZStatus_t zclClosures_ProcessInDoorLockGetUserType( zclIncoming_t *pInMsg,
    162                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs );
    163          static ZStatus_t zclClosures_ProcessInDoorLockSetRFIDCode( zclIncoming_t *pInMsg,
    164                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs );
    165          static ZStatus_t zclClosures_ProcessInDoorLockGetRFIDCode( zclIncoming_t *pInMsg,
    166                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs );
    167          static ZStatus_t zclClosures_ProcessInDoorLockClearRFIDCode( zclIncoming_t *pInMsg,
    168                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs );
    169          static ZStatus_t zclClosures_ProcessInDoorLockClearAllRFIDCodes( zclIncoming_t *pInMsg,
    170                                                                           zclClosures_DoorLockAppCallbacks_t *pCBs );
    171          static ZStatus_t zclClosures_ProcessInDoorLockSetTemporaryPin( zclIncoming_t *pInMsg,
    172                                                                         zclClosures_DoorLockAppCallbacks_t *pCBs );
    173          static ZStatus_t zclClosures_ModifyPin( zclIncoming_t *pInMsg,
    174                                                  zclClosures_DoorLockAppCallbacks_t *pCBs );
    175          static ZStatus_t zclClosures_ProcessInDoorLockUnlockWithTimeoutRsp( zclIncoming_t *pInMsg,
    176                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
    177          static ZStatus_t zclClosures_ProcessInDoorLockGetLogRecordRsp( zclIncoming_t *pInMsg,
    178                                                                         zclClosures_DoorLockAppCallbacks_t *pCBs );
    179          static ZStatus_t zclClosures_ProcessInDoorLockSetPINCodeRsp( zclIncoming_t *pInMsg,
    180                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs );
    181          static ZStatus_t zclClosures_ProcessInDoorLockGetPINCodeRsp( zclIncoming_t *pInMsg,
    182                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs );
    183          static ZStatus_t zclClosures_ProcessInDoorLockClearPINCodeRsp( zclIncoming_t *pInMsg,
    184                                                                         zclClosures_DoorLockAppCallbacks_t *pCBs );
    185          static ZStatus_t zclClosures_ProcessInDoorLockClearAllPINCodesRsp( zclIncoming_t *pInMsg,
    186                                                                             zclClosures_DoorLockAppCallbacks_t *pCBs );
    187          static ZStatus_t zclClosures_ProcessInDoorLockSetUserStatusRsp( zclIncoming_t *pInMsg,
    188                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs );
    189          static ZStatus_t zclClosures_ProcessInDoorLockGetUserStatusRsp( zclIncoming_t *pInMsg,
    190                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs );
    191          static ZStatus_t zclClosures_ProcessInDoorLockSetWeekDayScheduleRsp( zclIncoming_t *pInMsg,
    192                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs );
    193          static ZStatus_t zclClosures_ProcessInDoorLockGetWeekDayScheduleRsp( zclIncoming_t *pInMsg,
    194                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs );
    195          static ZStatus_t zclClosures_ProcessInDoorLockClearWeekDayScheduleRsp( zclIncoming_t *pInMsg,
    196                                                                                 zclClosures_DoorLockAppCallbacks_t *pCBs );
    197          static ZStatus_t zclClosures_ProcessInDoorLockSetYearDayScheduleRsp( zclIncoming_t *pInMsg,
    198                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs );
    199          static ZStatus_t zclClosures_ProcessInDoorLockGetYearDayScheduleRsp( zclIncoming_t *pInMsg,
    200                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs );
    201          static ZStatus_t zclClosures_ProcessInDoorLockClearYearDayScheduleRsp( zclIncoming_t *pInMsg,
    202                                                                                 zclClosures_DoorLockAppCallbacks_t *pCBs );
    203          static ZStatus_t zclClosures_ProcessInDoorLockSetHolidayScheduleRsp( zclIncoming_t *pInMsg,
    204                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs );
    205          static ZStatus_t zclClosures_ProcessInDoorLockGetHolidayScheduleRsp( zclIncoming_t *pInMsg,
    206                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs );
    207          static ZStatus_t zclClosures_ProcessInDoorLockClearHolidayScheduleRsp( zclIncoming_t *pInMsg,
    208                                                                                 zclClosures_DoorLockAppCallbacks_t *pCBs );
    209          static ZStatus_t zclClosures_ProcessInDoorLockSetUserTypeRsp( zclIncoming_t *pInMsg,
    210                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs );
    211          static ZStatus_t zclClosures_ProcessInDoorLockGetUserTypeRsp( zclIncoming_t *pInMsg,
    212                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs );
    213          static ZStatus_t zclClosures_ProcessInDoorLockSetRFIDCodeRsp( zclIncoming_t *pInMsg,
    214                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs );
    215          static ZStatus_t zclClosures_ProcessInDoorLockGetRFIDCodeRsp( zclIncoming_t *pInMsg,
    216                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs );
    217          static ZStatus_t zclClosures_ProcessInDoorLockClearRFIDCodeRsp( zclIncoming_t *pInMsg,
    218                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs );
    219          static ZStatus_t zclClosures_ProcessInDoorLockClearAllRFIDCodesRsp( zclIncoming_t *pInMsg,
    220                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
    221          static ZStatus_t zclClosures_ProcessInDoorLockOperationEventNotification( zclIncoming_t *pInMsg,
    222                                                                                    zclClosures_DoorLockAppCallbacks_t *pCBs );
    223          static ZStatus_t zclClosures_ProcessInDoorLockProgrammingEventNotification( zclIncoming_t *pInMsg,
    224                                                                                      zclClosures_DoorLockAppCallbacks_t *pCBs );
    225          #endif //ZCL_DOORLOCK_EXT
    226          #endif //ZCL_DOORLOCK
    227          
    228          #ifdef ZCL_WINDOWCOVERING
    229          static zclClosures_WindowCoveringAppCallbacks_t *zclClosures_FindWCCallbacks( uint8 endpoint );
    230          static ZStatus_t zclClosures_ProcessInWindowCovering( zclIncoming_t *pInMsg,
    231                                                                zclClosures_WindowCoveringAppCallbacks_t *pCBs );
    232          #endif //ZCL_WINDOWCOVERING
    233          
    234          #ifdef ZCL_DOORLOCK
    235          /*********************************************************************
    236           * @fn      zclClosures_RegisterDoorLockCmdCallbacks
    237           *
    238           * @brief   Register an applications DoorLock command callbacks
    239           *
    240           * @param   endpoint - application's endpoint
    241           * @param   callbacks - pointer to the callback record.
    242           *
    243           * @return  ZMemError if not able to allocate
    244           */
    245          ZStatus_t zclClosures_RegisterDoorLockCmdCallbacks( uint8 endpoint, zclClosures_DoorLockAppCallbacks_t *callbacks )
    246          {
    247            zclClosuresDoorLockCBRec_t *pNewItem;
    248            zclClosuresDoorLockCBRec_t *pLoop;
    249          
    250            // Register as a ZCL Plugin
    251            if ( !zclDoorLockPluginRegisted )
    252            {
    253              zcl_registerPlugin( ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
    254                                  ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
    255                                  zclClosures_HdlIncoming );
    256              zclDoorLockPluginRegisted = TRUE;
    257            }
    258          
    259            // Fill in the new profile list
    260            pNewItem = zcl_mem_alloc( sizeof( zclClosuresDoorLockCBRec_t ) );
    261            if ( pNewItem == NULL )
    262            {
    263              return ( ZMemError );
    264            }
    265          
    266            pNewItem->next = (zclClosuresDoorLockCBRec_t *)NULL;
    267            pNewItem->endpoint = endpoint;
    268            pNewItem->CBs = callbacks;
    269          
    270            // Find spot in list
    271            if ( zclClosuresDoorLockCBs == NULL )
    272            {
    273              zclClosuresDoorLockCBs = pNewItem;
    274            }
    275            else
    276            {
    277              // Look for end of list
    278              pLoop = zclClosuresDoorLockCBs;
    279              while ( pLoop->next != NULL )
    280              {
    281                pLoop = pLoop->next;
    282              }
    283          
    284              // Put new item at end of list
    285              pLoop->next = pNewItem;
    286            }
    287            return ( ZSuccess );
    288          }
    289          
    290          /*********************************************************************
    291           * @fn      zclClosures_FindDoorLockCallbacks
    292           *
    293           * @brief   Find the DoorLock callbacks for an endpoint
    294           *
    295           * @param   endpoint
    296           *
    297           * @return  pointer to the callbacks
    298           */
    299          static zclClosures_DoorLockAppCallbacks_t *zclClosures_FindDoorLockCallbacks( uint8 endpoint )
    300          {
    301            zclClosuresDoorLockCBRec_t *pCBs;
    302          
    303            pCBs = zclClosuresDoorLockCBs;
    304            while ( pCBs )
    305            {
    306              if ( pCBs->endpoint == endpoint )
    307              {
    308                return ( pCBs->CBs );
    309              }
    310              pCBs = pCBs->next;
    311            }
    312            return ( (zclClosures_DoorLockAppCallbacks_t *)NULL );
    313          }
    314          #endif // ZCL_DOORLOCK
    315          
    316          #ifdef ZCL_WINDOWCOVERING
    317          /*********************************************************************
    318           * @fn      zclClosures_RegisterWindowCoveringCmdCallbacks
    319           *
    320           * @brief   Register an applications Window Covering command callbacks
    321           *
    322           * @param   endpoint - application's endpoint
    323           * @param   callbacks - pointer to the callback record.
    324           *
    325           * @return  ZMemError if not able to allocate
    326           */
    327          ZStatus_t zclClosures_RegisterWindowCoveringCmdCallbacks( uint8 endpoint, zclClosures_WindowCoveringAppCallbacks_t *callbacks )
    328          {
    329            zclClosuresWindowCoveringCBRec_t *pNewItem;
    330            zclClosuresWindowCoveringCBRec_t *pLoop;
    331          
    332            // Register as a ZCL Plugin
    333            if ( !zclWindowCoveringPluginRegisted )
    334            {
    335              zcl_registerPlugin( ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING,
    336                                  ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING,
    337                                  zclClosures_HdlIncoming );
    338              zclWindowCoveringPluginRegisted = TRUE;
    339            }
    340          
    341            // Fill in the new profile list
    342            pNewItem = zcl_mem_alloc( sizeof( zclClosuresWindowCoveringCBRec_t ) );
    343            if ( pNewItem == NULL )
    344            {
    345              return ( ZMemError );
    346            }
    347          
    348            pNewItem->next = (zclClosuresWindowCoveringCBRec_t *)NULL;
    349            pNewItem->endpoint = endpoint;
    350            pNewItem->CBs = callbacks;
    351          
    352            // Find spot in list
    353            if ( zclClosuresWindowCoveringCBs == NULL )
    354            {
    355              zclClosuresWindowCoveringCBs = pNewItem;
    356            }
    357            else
    358            {
    359              // Look for end of list
    360              pLoop = zclClosuresWindowCoveringCBs;
    361              while ( pLoop->next != NULL )
    362              {
    363                pLoop = pLoop->next;
    364              }
    365          
    366              // Put new item at end of list
    367              pLoop->next = pNewItem;
    368            }
    369            return ( ZSuccess );
    370          }
    371          
    372          /*********************************************************************
    373           * @fn      zclClosures_FindWCCallbacks
    374           *
    375           * @brief   Find the Window Covering callbacks for an endpoint
    376           *
    377           * @param   endpoint
    378           *
    379           * @return  pointer to the callbacks
    380           */
    381          static zclClosures_WindowCoveringAppCallbacks_t *zclClosures_FindWCCallbacks( uint8 endpoint )
    382          {
    383            zclClosuresWindowCoveringCBRec_t *pCBs;
    384          
    385            pCBs = zclClosuresWindowCoveringCBs;
    386            while ( pCBs )
    387            {
    388              if ( pCBs->endpoint == endpoint )
    389              {
    390                return ( pCBs->CBs );
    391              }
    392              pCBs = pCBs->next;
    393            }
    394            return ( (zclClosures_WindowCoveringAppCallbacks_t *)NULL );
    395          }
    396          #endif // ZCL_WINDOWCOVERING
    397          
    398          #if defined(ZCL_DOORLOCK) || defined(ZCL_WINDOWCOVERING)
    399          /*********************************************************************
    400           * @fn      zclClosures_HdlIncoming
    401           *
    402           * @brief   Callback from ZCL to process incoming Commands specific
    403           *          to this cluster library or Profile commands for attributes
    404           *          that aren't in the attribute list
    405           *
    406           * @param   pInMsg - pointer to the incoming message
    407           * @param   logicalClusterID
    408           *
    409           * @return  ZStatus_t
    410           */
    411          static ZStatus_t zclClosures_HdlIncoming( zclIncoming_t *pInMsg )
    412          {
    413            ZStatus_t stat = ZSuccess;
    414          
    415          #if defined ( INTER_PAN )
    416            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
    417              return ( stat ); // Cluster not supported thru Inter-PAN
    418          #endif
    419            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
    420            {
    421              // Is this a manufacturer specific command?
    422              if ( pInMsg->hdr.fc.manuSpecific == 0 )
    423              {
    424                stat = zclClosures_HdlInSpecificCommands( pInMsg );
    425              }
    426              else
    427              {
    428                // We don't support any manufacturer specific command.
    429                stat = ZFailure;
    430              }
    431            }
    432            else
    433            {
    434              // Handle all the normal (Read, Write...) commands -- should never get here
    435              stat = ZFailure;
    436            }
    437            return ( stat );
    438          }
    439          
    440          /*********************************************************************
    441           * @fn      zclClosures_HdlInSpecificCommands
    442           *
    443           * @brief   Callback from ZCL to process incoming Commands specific
    444           *          to this cluster library
    445          
    446           * @param   pInMsg - pointer to the incoming message
    447           *
    448           * @return  ZStatus_t
    449           */
    450          static ZStatus_t zclClosures_HdlInSpecificCommands( zclIncoming_t *pInMsg )
    451          {
    452            ZStatus_t stat;
    453          #ifdef ZCL_DOORLOCK
    454            zclClosures_DoorLockAppCallbacks_t *pDLCBs;
    455          #endif
    456          
    457          #ifdef ZCL_WINDOWCOVERING
    458            zclClosures_WindowCoveringAppCallbacks_t *pWCCBs;
    459          #endif
    460          
    461          #ifdef ZCL_DOORLOCK
    462            // make sure endpoint exists
    463            pDLCBs = zclClosures_FindDoorLockCallbacks( pInMsg->msg->endPoint );
    464            if ( pDLCBs == NULL )
    465            {
    466              return ( ZFailure );
    467            }
    468          #endif
    469          
    470          #ifdef ZCL_WINDOWCOVERING
    471            // make sure endpoint exists
    472            pWCCBs = zclClosures_FindWCCallbacks( pInMsg->msg->endPoint );
    473            if ( pWCCBs == NULL )
    474            {
    475              return ( ZFailure );
    476            }
    477          #endif
    478          
    479            switch ( pInMsg->msg->clusterId )
    480            {
    481              case ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK:
    482          #ifdef ZCL_DOORLOCK
    483                stat = zclClosures_ProcessInDoorLockCmds( pInMsg, pDLCBs );
    484          #endif //ZCL_DOORLOCK
    485                break;
    486          
    487              case ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING:
    488          #ifdef ZCL_WINDOWCOVERING
    489                stat = zclClosures_ProcessInWindowCovering( pInMsg, pWCCBs );
    490          #endif //ZCL_WINDOWCOVERING
    491                break;
    492          
    493              default:
    494                stat = ZFailure;
    495                break;
    496            }
    497          
    498            return ( stat );
    499          }
    500          #endif // defined(ZCL_DOORLOCK) || defined(ZCL_WINDOWCOVERING)
    501          
    502          #ifdef ZCL_DOORLOCK
    503          /*********************************************************************
    504           * @fn      zclClosures_ProcessInDoorLockCmds
    505           *
    506           * @brief   Process in the received DoorLock Command.
    507           *
    508           * @param   pInMsg - pointer to the incoming message
    509           * @param   pCBs - pointer to the Application callback functions
    510           *
    511           * @return  ZStatus_t
    512           */
    513          static ZStatus_t zclClosures_ProcessInDoorLockCmds( zclIncoming_t *pInMsg,
    514                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
    515          {
    516            ZStatus_t stat;
    517          
    518            // Client-to-Server
    519            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
    520            {
    521              switch(pInMsg->hdr.commandID)
    522              {
    523                case COMMAND_CLOSURES_LOCK_DOOR:
    524                case COMMAND_CLOSURES_UNLOCK_DOOR:
    525                case COMMAND_CLOSURES_TOGGLE_DOOR:
    526                  stat = zclClosures_ProcessInDoorLock( pInMsg, pCBs );
    527                  break;
    528                  
    529          #ifdef ZCL_DOORLOCK_EXT
    530                case COMMAND_CLOSURES_UNLOCK_WITH_TIMEOUT:
    531                  stat = zclClosures_ProcessInDoorLockUnlockWithTimeout( pInMsg, pCBs );
    532                  break;
    533          
    534                case COMMAND_CLOSURES_GET_LOG_RECORD:
    535                  stat = zclClosures_ProcessInDoorLockGetLogRecord( pInMsg, pCBs );
    536                  break;
    537          
    538                case COMMAND_CLOSURES_SET_PIN_CODE:
    539                  stat = zclClosures_ProcessInDoorLockSetPINCode( pInMsg, pCBs );
    540                  break;
    541          
    542                case COMMAND_CLOSURES_GET_PIN_CODE:
    543                  stat = zclClosures_ProcessInDoorLockGetPINCode( pInMsg, pCBs );
    544                  break;
    545          
    546                case COMMAND_CLOSURES_CLEAR_PIN_CODE:
    547                  stat = zclClosures_ProcessInDoorLockClearPINCode( pInMsg, pCBs );
    548                  break;
    549          
    550                case COMMAND_CLOSURES_CLEAR_ALL_PIN_CODES:
    551                  stat = zclClosures_ProcessInDoorLockClearAllPINCodes( pInMsg, pCBs );
    552                  break;
    553          
    554                case COMMAND_CLOSURES_SET_USER_STATUS:
    555                  stat = zclClosures_ProcessInDoorLockSetUserStatus( pInMsg, pCBs );
    556                  break;
    557          
    558                case COMMAND_CLOSURES_GET_USER_STATUS:
    559                  stat = zclClosures_ProcessInDoorLockGetUserStatus( pInMsg, pCBs );
    560                  break;
    561          
    562                case COMMAND_CLOSURES_SET_WEEK_DAY_SCHEDULE:
    563                  stat = zclClosures_ProcessInDoorLockSetWeekDaySchedule( pInMsg, pCBs );
    564                  break;
    565          
    566                case COMMAND_CLOSURES_GET_WEEK_DAY_SCHEDULE:
    567                  stat = zclClosures_ProcessInDoorLockGetWeekDaySchedule( pInMsg, pCBs );
    568                  break;
    569          
    570                case COMMAND_CLOSURES_CLEAR_WEEK_DAY_SCHEDULE:
    571                  stat = zclClosures_ProcessInDoorLockClearWeekDaySchedule( pInMsg, pCBs );
    572                  break;
    573          
    574                case COMMAND_CLOSURES_SET_YEAR_DAY_SCHEDULE:
    575                  stat = zclClosures_ProcessInDoorLockSetYearDaySchedule( pInMsg, pCBs );
    576                  break;
    577          
    578                case COMMAND_CLOSURES_GET_YEAR_DAY_SCHEDULE:
    579                  stat = zclClosures_ProcessInDoorLockGetYearDaySchedule( pInMsg, pCBs );
    580                  break;
    581          
    582                case COMMAND_CLOSURES_CLEAR_YEAR_DAY_SCHEDULE:
    583                  stat = zclClosures_ProcessInDoorLockClearYearDaySchedule( pInMsg, pCBs );
    584                  break;
    585          
    586                case COMMAND_CLOSURES_SET_HOLIDAY_SCHEDULE:
    587                  stat = zclClosures_ProcessInDoorLockSetHolidaySchedule( pInMsg, pCBs );
    588                  break;
    589          
    590                case COMMAND_CLOSURES_GET_HOLIDAY_SCHEDULE:
    591                  stat = zclClosures_ProcessInDoorLockGetHolidaySchedule( pInMsg, pCBs );
    592                  break;
    593          
    594                case COMMAND_CLOSURES_CLEAR_HOLIDAY_SCHEDULE:
    595                  stat = zclClosures_ProcessInDoorLockClearHolidaySchedule( pInMsg, pCBs );
    596                  break;
    597          
    598                case COMMAND_CLOSURES_SET_USER_TYPE:
    599                  stat = zclClosures_ProcessInDoorLockSetUserType( pInMsg, pCBs );
    600                  break;
    601          
    602                case COMMAND_CLOSURES_GET_USER_TYPE:
    603                  stat = zclClosures_ProcessInDoorLockGetUserType( pInMsg, pCBs );
    604                  break;
    605          
    606                case COMMAND_CLOSURES_SET_RFID_CODE:
    607                  stat = zclClosures_ProcessInDoorLockSetRFIDCode( pInMsg, pCBs );
    608                  break;
    609          
    610                case COMMAND_CLOSURES_GET_RFID_CODE:
    611                  stat = zclClosures_ProcessInDoorLockGetRFIDCode( pInMsg, pCBs );
    612                  break;
    613          
    614                case COMMAND_CLOSURES_CLEAR_RFID_CODE:
    615                  stat = zclClosures_ProcessInDoorLockClearRFIDCode( pInMsg, pCBs );
    616                  break;
    617          
    618                case COMMAND_CLOSURES_CLEAR_ALL_RFID_CODES:
    619                  stat = zclClosures_ProcessInDoorLockClearAllRFIDCodes( pInMsg, pCBs );
    620                  break;
    621                  
    622                case COMMAND_CLOSURES_SET_TEMPORARY_PIN:
    623                  stat = zclClosures_ProcessInDoorLockSetTemporaryPin( pInMsg, pCBs );
    624                  break;
    625                  
    626                case COMMAND_CLOSURES_MODIFY_PIN:
    627                  stat = zclClosures_ModifyPin( pInMsg, pCBs );
    628                  break;            
    629                  
    630          #endif
    631                default:
    632                  // Unknown command
    633                  stat = ZFailure;
    634                  break;
    635              }
    636            }
    637            // Server-to-Client
    638            else
    639            {
    640              switch(pInMsg->hdr.commandID)
    641              {
    642                case COMMAND_CLOSURES_LOCK_DOOR_RSP:
    643                case COMMAND_CLOSURES_UNLOCK_DOOR_RSP:
    644                case COMMAND_CLOSURES_TOGGLE_DOOR_RSP:
    645                  stat = zclClosures_ProcessInDoorLock( pInMsg, pCBs );
    646                  break;
    647                  
    648          #ifdef ZCL_DOORLOCK_EXT
    649                  
    650                case COMMAND_CLOSURES_UNLOCK_WITH_TIMEOUT_RSP:
    651                  stat = zclClosures_ProcessInDoorLockUnlockWithTimeoutRsp( pInMsg, pCBs );
    652                  break;
    653          
    654                case COMMAND_CLOSURES_GET_LOG_RECORD_RSP:
    655                  stat = zclClosures_ProcessInDoorLockGetLogRecordRsp( pInMsg, pCBs );
    656                  break;
    657          
    658                case COMMAND_CLOSURES_SET_PIN_CODE_RSP:
    659                  stat = zclClosures_ProcessInDoorLockSetPINCodeRsp( pInMsg, pCBs );
    660                  break;
    661          
    662                case COMMAND_CLOSURES_GET_PIN_CODE_RSP:
    663                  stat = zclClosures_ProcessInDoorLockGetPINCodeRsp( pInMsg, pCBs );
    664                  break;
    665          
    666                case COMMAND_CLOSURES_CLEAR_PIN_CODE_RSP:
    667                  stat = zclClosures_ProcessInDoorLockClearPINCodeRsp( pInMsg, pCBs );
    668                  break;
    669          
    670                case COMMAND_CLOSURES_CLEAR_ALL_PIN_CODES_RSP:
    671                  stat = zclClosures_ProcessInDoorLockClearAllPINCodesRsp( pInMsg, pCBs );
    672                  break;
    673          
    674                case COMMAND_CLOSURES_SET_USER_STATUS_RSP:
    675                  stat = zclClosures_ProcessInDoorLockSetUserStatusRsp( pInMsg, pCBs );
    676                  break;
    677          
    678                case COMMAND_CLOSURES_GET_USER_STATUS_RSP:
    679                  stat = zclClosures_ProcessInDoorLockGetUserStatusRsp( pInMsg, pCBs );
    680                  break;
    681          
    682                case COMMAND_CLOSURES_SET_WEEK_DAY_SCHEDULE_RSP:
    683                  stat = zclClosures_ProcessInDoorLockSetWeekDayScheduleRsp( pInMsg, pCBs );
    684                  break;
    685          
    686                case COMMAND_CLOSURES_GET_WEEK_DAY_SCHEDULE_RSP:
    687                  stat = zclClosures_ProcessInDoorLockGetWeekDayScheduleRsp( pInMsg, pCBs );
    688                  break;
    689          
    690                case COMMAND_CLOSURES_CLEAR_WEEK_DAY_SCHEDULE_RSP:
    691                  stat = zclClosures_ProcessInDoorLockClearWeekDayScheduleRsp( pInMsg, pCBs );
    692                  break;
    693          
    694                case COMMAND_CLOSURES_SET_YEAR_DAY_SCHEDULE_RSP:
    695                  stat = zclClosures_ProcessInDoorLockSetYearDayScheduleRsp( pInMsg, pCBs );
    696                  break;
    697          
    698                case COMMAND_CLOSURES_GET_YEAR_DAY_SCHEDULE_RSP:
    699                  stat = zclClosures_ProcessInDoorLockGetYearDayScheduleRsp( pInMsg, pCBs );
    700                  break;
    701          
    702                case COMMAND_CLOSURES_CLEAR_YEAR_DAY_SCHEDULE_RSP:
    703                  stat = zclClosures_ProcessInDoorLockClearYearDayScheduleRsp( pInMsg, pCBs );
    704                  break;
    705          
    706                case COMMAND_CLOSURES_SET_HOLIDAY_SCHEDULE_RSP:
    707                  stat = zclClosures_ProcessInDoorLockSetHolidayScheduleRsp( pInMsg, pCBs );
    708                  break;
    709          
    710                case COMMAND_CLOSURES_GET_HOLIDAY_SCHEDULE_RSP:
    711                  stat = zclClosures_ProcessInDoorLockGetHolidayScheduleRsp( pInMsg, pCBs );
    712                  break;
    713          
    714                case COMMAND_CLOSURES_CLEAR_HOLIDAY_SCHEDULE_RSP:
    715                  stat = zclClosures_ProcessInDoorLockClearHolidayScheduleRsp( pInMsg, pCBs );
    716                  break;
    717          
    718                case COMMAND_CLOSURES_SET_USER_TYPE_RSP:
    719                  stat = zclClosures_ProcessInDoorLockSetUserTypeRsp( pInMsg, pCBs );
    720                  break;
    721          
    722                case COMMAND_CLOSURES_GET_USER_TYPE_RSP:
    723                  stat = zclClosures_ProcessInDoorLockGetUserTypeRsp( pInMsg, pCBs );
    724                  break;
    725          
    726                case COMMAND_CLOSURES_SET_RFID_CODE_RSP:
    727                  stat = zclClosures_ProcessInDoorLockSetRFIDCodeRsp( pInMsg, pCBs );
    728                  break;
    729          
    730                case COMMAND_CLOSURES_GET_RFID_CODE_RSP:
    731                  stat = zclClosures_ProcessInDoorLockGetRFIDCodeRsp( pInMsg, pCBs );
    732                  break;
    733          
    734                case COMMAND_CLOSURES_CLEAR_RFID_CODE_RSP:
    735                  stat = zclClosures_ProcessInDoorLockClearRFIDCodeRsp( pInMsg, pCBs );
    736                  break;
    737          
    738                case COMMAND_CLOSURES_CLEAR_ALL_RFID_CODES_RSP:
    739                  stat = zclClosures_ProcessInDoorLockClearAllRFIDCodesRsp( pInMsg, pCBs );
    740                  break;
    741          
    742                case COMMAND_CLOSURES_OPERATION_EVENT_NOTIFICATION:
    743                  stat = zclClosures_ProcessInDoorLockOperationEventNotification( pInMsg, pCBs );
    744                  break;
    745          
    746                case COMMAND_CLOSURES_PROGRAMMING_EVENT_NOTIFICATION:
    747                  stat = zclClosures_ProcessInDoorLockProgrammingEventNotification( pInMsg, pCBs );
    748                  break;     
    749                  
    750          #endif //ZCL_DOORLOCK_EXT
    751          
    752                default:
    753                  // Unknown command
    754                  stat = ZFailure;
    755                  break;
    756              }
    757            }
    758          
    759            return ( stat );
    760          }
    761          
    762          /*********************************************************************
    763           * @fn      zclClosures_ProcessInDoorLock
    764           *
    765           * @brief   Process in the received Door Lock cmds
    766           *
    767           * @param   pInMsg - pointer to the incoming message
    768           * @param   pCBs - pointer to the application callbacks
    769           *
    770           * @return  ZStatus_t
    771           */
    772          static ZStatus_t zclClosures_ProcessInDoorLock( zclIncoming_t *pInMsg,
    773                                                          zclClosures_DoorLockAppCallbacks_t *pCBs )
    774          {
    775            ZStatus_t status;
    776          
    777            // Client-to-Server
    778            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
    779            {
    780              switch(pInMsg->hdr.commandID)
    781              {
    782                case COMMAND_CLOSURES_LOCK_DOOR:
    783                case COMMAND_CLOSURES_UNLOCK_DOOR:
    784                case COMMAND_CLOSURES_TOGGLE_DOOR:
    785                  if ( pCBs->pfnDoorLock )
    786                  {
    787                    uint8 i;
    788                    uint8 calculatedArrayLen;
    789                    zclDoorLock_t cmd;
    790          
    791                    // first octet of PIN/RFID Code variable string identifies its length
    792                    calculatedArrayLen = pInMsg->pData[0] + 1; // add first byte of string
    793          
    794                    cmd.pPinRfidCode = zcl_mem_alloc( calculatedArrayLen );
    795          
    796                    if ( !cmd.pPinRfidCode )
    797                    {
    798                      return ( ZMemError );  // no memory
    799                    }
    800          
    801                    for ( i = 0; i < calculatedArrayLen; i++ )
    802                    {
    803                      cmd.pPinRfidCode[i] = pInMsg->pData[i];
    804                    }
    805          
    806                    status = ( pCBs->pfnDoorLock( pInMsg, &cmd ) );
    807                    zcl_mem_free( cmd.pPinRfidCode );
    808                    return status;
    809                  }
    810          
    811                  return ( ZCL_STATUS_FAILURE );
    812                  break;
    813          
    814                default:
    815                  return ( ZFailure );   // Error ignore the command
    816              }
    817            }
    818            // Server-to-Client
    819            else
    820            {
    821              switch(pInMsg->hdr.commandID)
    822              {
    823                case COMMAND_CLOSURES_LOCK_DOOR_RSP:
    824                case COMMAND_CLOSURES_UNLOCK_DOOR_RSP:
    825                case COMMAND_CLOSURES_TOGGLE_DOOR_RSP:
    826                  if ( pCBs->pfnDoorLockRsp )
    827                  {
    828                    return ( pCBs->pfnDoorLockRsp( pInMsg, pInMsg->pData[0] ) );
    829                  }
    830          
    831                  return ( ZCL_STATUS_FAILURE );
    832                  break;
    833          
    834                default:
    835                  return ( ZFailure );   // Error ignore the command
    836              }
    837            }
    838          }
    839          
    840          #ifdef ZCL_DOORLOCK_EXT
    841          /*********************************************************************
    842           * @fn      zclClosures_ProcessInDoorLockUnlockWithTimeout
    843           *
    844           * @brief   Process in the received Unlock With Timeout cmd
    845           *
    846           * @param   pInMsg - pointer to the incoming message
    847           * @param   pCBs - pointer to the application callbacks
    848           *
    849           * @return  ZStatus_t
    850           */
    851          static ZStatus_t zclClosures_ProcessInDoorLockUnlockWithTimeout( zclIncoming_t *pInMsg,
    852                                                                           zclClosures_DoorLockAppCallbacks_t *pCBs )
    853          {
    854            ZStatus_t status;
    855          
    856            if ( pCBs->pfnDoorLockUnlockWithTimeout )
    857            {
    858              uint8 i;
    859              uint8 offset;
    860              uint8 calculatedArrayLen;
    861              zclDoorLockUnlockTimeout_t cmd;
    862          
    863              // first octet of PIN/RFID Code variable string identifies its length
    864              calculatedArrayLen = pInMsg->pData[2] + 1;  // add first byte of string
    865          
    866              cmd.pPinRfidCode = zcl_mem_alloc( calculatedArrayLen );
    867              if ( !cmd.pPinRfidCode )
    868              {
    869                return ( ZMemError );  // no memory
    870              }
    871          
    872              cmd.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
    873              offset = 2;
    874              for ( i = 0; i < calculatedArrayLen; i++ )
    875              {
    876                cmd.pPinRfidCode[i] = pInMsg->pData[offset++];
    877              }
    878          
    879              status = ( pCBs->pfnDoorLockUnlockWithTimeout( pInMsg, &cmd ) );
    880              zcl_mem_free( cmd.pPinRfidCode );
    881              return status;
    882            }
    883          
    884            return ( ZFailure );
    885          }
    886          
    887          /*********************************************************************
    888           * @fn      zclClosures_ProcessInDoorLockGetLogRecord
    889           *
    890           * @brief   Process in the received Get Log Record cmd
    891           *
    892           * @param   pInMsg - pointer to the incoming message
    893           * @param   pCBs - pointer to the application callbacks
    894           *
    895           * @return  ZStatus_t
    896           */
    897          static ZStatus_t zclClosures_ProcessInDoorLockGetLogRecord( zclIncoming_t *pInMsg,
    898                                                                      zclClosures_DoorLockAppCallbacks_t *pCBs )
    899          {
    900            if ( pCBs->pfnDoorLockGetLogRecord )
    901            {
    902              zclDoorLockGetLogRecord_t cmd;
    903          
    904              cmd.logIndex = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
    905          
    906              return ( pCBs->pfnDoorLockGetLogRecord( pInMsg, &cmd ) );
    907            }
    908          
    909            return ( ZFailure );
    910          }
    911          
    912          /*********************************************************************
    913           * @fn      zclClosures_ProcessInDoorLockSetPINCode
    914           *
    915           * @brief   Process in the received Set PIN Code cmd
    916           *
    917           * @param   pInMsg - pointer to the incoming message
    918           * @param   pCBs - pointer to the application callbacks
    919           *
    920           * @return  ZStatus_t
    921           */
    922          static ZStatus_t zclClosures_ProcessInDoorLockSetPINCode( zclIncoming_t *pInMsg,
    923                                                                    zclClosures_DoorLockAppCallbacks_t *pCBs )
    924          {
    925           if ( pCBs->pfnDoorLockSetPINCode )
    926           {
    927              uint8 i;
    928              uint8 offset;
    929              uint8 calculatedArrayLen;
    930              zclDoorLockSetPINCode_t cmd;
    931              ZStatus_t status;
    932          
    933              // first octet of PIN/RFID Code variable string identifies its length
    934              calculatedArrayLen = pInMsg->pData[4] + 1; // add first byte of string
    935          
    936              cmd.pPIN = zcl_mem_alloc( calculatedArrayLen );
    937              if ( !cmd.pPIN )
    938              {
    939                return ( ZMemError );  // no memory
    940              }
    941          
    942              cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
    943              cmd.userStatus = pInMsg->pData[2];
    944              cmd.userType = pInMsg->pData[3];
    945              offset = 4;
    946              for ( i = 0; i < calculatedArrayLen; i++ )
    947              {
    948                cmd.pPIN[i] = pInMsg->pData[offset++];
    949              }
    950          
    951              status = ( pCBs->pfnDoorLockSetPINCode( pInMsg, &cmd ) );
    952              zcl_mem_free( cmd.pPIN );
    953              return status;
    954           }
    955          
    956           return ( ZFailure );
    957          }
    958          
    959          /*********************************************************************
    960           * @fn      zclClosures_ProcessInDoorLockGetPINCode
    961           *
    962           * @brief   Process in the received Get PIN Code cmd
    963           *
    964           * @param   pInMsg - pointer to the incoming message
    965           * @param   pCBs - pointer to the application callbacks
    966           *
    967           * @return  ZStatus_t
    968           */
    969          static ZStatus_t zclClosures_ProcessInDoorLockGetPINCode( zclIncoming_t *pInMsg,
    970                                                                    zclClosures_DoorLockAppCallbacks_t *pCBs )
    971          {
    972           if ( pCBs->pfnDoorLockGetPINCode )
    973           {
    974             zclDoorLockUserID_t cmd;
    975          
    976             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
    977          
    978             return ( pCBs->pfnDoorLockGetPINCode( pInMsg, &cmd ) );
    979           }
    980          
    981           return ( ZFailure );
    982          }
    983          
    984          /*********************************************************************
    985           * @fn      zclClosures_ProcessInDoorLockClearPINCode
    986           *
    987           * @brief   Process in the received Clear PIN Code cmd
    988           *
    989           * @param   pInMsg - pointer to the incoming message
    990           * @param   pCBs - pointer to the application callbacks
    991           *
    992           * @return  ZStatus_t
    993           */
    994          static ZStatus_t zclClosures_ProcessInDoorLockClearPINCode( zclIncoming_t *pInMsg,
    995                                                                      zclClosures_DoorLockAppCallbacks_t *pCBs )
    996          {
    997           if ( pCBs->pfnDoorLockClearPINCode )
    998           {
    999             zclDoorLockUserID_t cmd;
   1000          
   1001             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1002          
   1003             return ( pCBs->pfnDoorLockClearPINCode( pInMsg, &cmd ) );
   1004           }
   1005          
   1006           return ( ZFailure );
   1007          }
   1008          
   1009          /*********************************************************************
   1010           * @fn      zclClosures_ProcessInDoorLockClearAllPINCodes
   1011           *
   1012           * @brief   Process in the received Clear All PIN Codes cmd
   1013           *
   1014           * @param   pInMsg - pointer to the incoming message
   1015           * @param   pCBs - pointer to the application callbacks
   1016           *
   1017           * @return  ZStatus_t
   1018           */
   1019          static ZStatus_t zclClosures_ProcessInDoorLockClearAllPINCodes( zclIncoming_t *pInMsg,
   1020                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs )
   1021          {
   1022           if ( pCBs->pfnDoorLockClearAllPINCodes )
   1023           {
   1024             // no payload
   1025          
   1026             return ( pCBs->pfnDoorLockClearAllPINCodes( pInMsg ) );
   1027           }
   1028          
   1029           return ( ZFailure );
   1030          }
   1031          
   1032          /*********************************************************************
   1033           * @fn      zclClosures_ProcessInDoorLockSetUserStatus
   1034           *
   1035           * @brief   Process in the received Set User Status cmd
   1036           *
   1037           * @param   pInMsg - pointer to the incoming message
   1038           * @param   pCBs - pointer to the application callbacks
   1039           *
   1040           * @return  ZStatus_t
   1041           */
   1042          static ZStatus_t zclClosures_ProcessInDoorLockSetUserStatus( zclIncoming_t *pInMsg,
   1043                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs )
   1044          {
   1045           if ( pCBs->pfnDoorLockSetUserStatus )
   1046           {
   1047             zclDoorLockSetUserStatus_t cmd;
   1048          
   1049             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1050             cmd.userStatus = pInMsg->pData[2];
   1051          
   1052             return ( pCBs->pfnDoorLockSetUserStatus( pInMsg, &cmd ) );
   1053           }
   1054          
   1055           return ( ZFailure );
   1056          }
   1057          
   1058          /*********************************************************************
   1059           * @fn      zclClosures_ProcessInDoorLockGetUserStatus
   1060           *
   1061           * @brief   Process in the received Get User Status cmd
   1062           *
   1063           * @param   pInMsg - pointer to the incoming message
   1064           * @param   pCBs - pointer to the application callbacks
   1065           *
   1066           * @return  ZStatus_t
   1067           */
   1068          static ZStatus_t zclClosures_ProcessInDoorLockGetUserStatus( zclIncoming_t *pInMsg,
   1069                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs )
   1070          {
   1071           if ( pCBs->pfnDoorLockGetUserStatus )
   1072           {
   1073             zclDoorLockUserID_t cmd;
   1074          
   1075             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1076          
   1077             return ( pCBs->pfnDoorLockGetUserStatus( pInMsg, &cmd ) );
   1078           }
   1079          
   1080           return ( ZFailure );
   1081          }
   1082          
   1083          /*********************************************************************
   1084           * @fn      zclClosures_ProcessInDoorLockSetWeekDaySchedule
   1085           *
   1086           * @brief   Process in the received Set Week Day Schedule cmd
   1087           *
   1088           * @param   pInMsg - pointer to the incoming message
   1089           * @param   pCBs - pointer to the application callbacks
   1090           *
   1091           * @return  ZStatus_t
   1092           */
   1093          static ZStatus_t zclClosures_ProcessInDoorLockSetWeekDaySchedule( zclIncoming_t *pInMsg,
   1094                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs )
   1095          {
   1096           if ( pCBs->pfnDoorLockSetWeekDaySchedule )
   1097           {
   1098             zclDoorLockSetWeekDaySchedule_t cmd;
   1099          
   1100             cmd.scheduleID = pInMsg->pData[0];
   1101             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1102             cmd.daysMask = pInMsg->pData[3];
   1103             cmd.startHour = pInMsg->pData[4];
   1104             cmd.startMinute = pInMsg->pData[5];
   1105             cmd.endHour = pInMsg->pData[6];
   1106             cmd.endMinute = pInMsg->pData[7];
   1107          
   1108             return ( pCBs->pfnDoorLockSetWeekDaySchedule( pInMsg, &cmd ) );
   1109           }
   1110          
   1111           return ( ZFailure );
   1112          }
   1113          
   1114          /*********************************************************************
   1115           * @fn      zclClosures_ProcessInDoorLockGetWeekDaySchedule
   1116           *
   1117           * @brief   Process in the received Get Week Day Schedule cmd
   1118           *
   1119           * @param   pInMsg - pointer to the incoming message
   1120           * @param   pCBs - pointer to the application callbacks
   1121           *
   1122           * @return  ZStatus_t
   1123           */
   1124          static ZStatus_t zclClosures_ProcessInDoorLockGetWeekDaySchedule( zclIncoming_t *pInMsg,
   1125                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs )
   1126          {
   1127           if ( pCBs->pfnDoorLockGetWeekDaySchedule )
   1128           {
   1129             zclDoorLockSchedule_t cmd;
   1130          
   1131             cmd.scheduleID = pInMsg->pData[0];
   1132             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1133          
   1134             return ( pCBs->pfnDoorLockGetWeekDaySchedule( pInMsg, &cmd ) );
   1135           }
   1136          
   1137           return ( ZFailure );
   1138          }
   1139          
   1140          /*********************************************************************
   1141           * @fn      zclClosures_ProcessInDoorLockClearWeekDaySchedule
   1142           *
   1143           * @brief   Process in the received Clear Week Day Schedule cmd
   1144           *
   1145           * @param   pInMsg - pointer to the incoming message
   1146           * @param   pCBs - pointer to the application callbacks
   1147           *
   1148           * @return  ZStatus_t
   1149           */
   1150          static ZStatus_t zclClosures_ProcessInDoorLockClearWeekDaySchedule( zclIncoming_t *pInMsg,
   1151                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
   1152          {
   1153           if ( pCBs->pfnDoorLockClearWeekDaySchedule )
   1154           {
   1155             zclDoorLockSchedule_t cmd;
   1156          
   1157             cmd.scheduleID = pInMsg->pData[0];
   1158             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1159          
   1160             return ( pCBs->pfnDoorLockClearWeekDaySchedule( pInMsg, &cmd ) );
   1161           }
   1162          
   1163           return ( ZFailure );
   1164          }
   1165          /*********************************************************************
   1166           * @fn      zclClosures_ProcessInDoorLockSetYearDaySchedule
   1167           *
   1168           * @brief   Process in the received Set Year Day Schedule cmd
   1169           *
   1170           * @param   pInMsg - pointer to the incoming message
   1171           * @param   pCBs - pointer to the application callbacks
   1172           *
   1173           * @return  ZStatus_t
   1174           */
   1175          static ZStatus_t zclClosures_ProcessInDoorLockSetYearDaySchedule( zclIncoming_t *pInMsg,
   1176                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs )
   1177          {
   1178           if ( pCBs->pfnDoorLockSetYearDaySchedule )
   1179           {
   1180             zclDoorLockSetYearDaySchedule_t cmd;
   1181          
   1182             cmd.scheduleID = pInMsg->pData[0];
   1183             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1184             cmd.zigBeeLocalStartTime = BUILD_UINT32( pInMsg->pData[3], pInMsg->pData[4], pInMsg->pData[5], pInMsg->pData[6] );
   1185             cmd.zigBeeLocalEndTime = BUILD_UINT32( pInMsg->pData[7], pInMsg->pData[8], pInMsg->pData[9], pInMsg->pData[10] );
   1186          
   1187             return ( pCBs->pfnDoorLockSetYearDaySchedule( pInMsg, &cmd ) );
   1188           }
   1189          
   1190           return ( ZFailure );
   1191          }
   1192          
   1193          /*********************************************************************
   1194           * @fn      zclClosures_ProcessInDoorLockGetYearDaySchedule
   1195           *
   1196           * @brief   Process in the received Get Year Day Schedule cmd
   1197           *
   1198           * @param   pInMsg - pointer to the incoming message
   1199           * @param   pCBs - pointer to the application callbacks
   1200           *
   1201           * @return  ZStatus_t
   1202           */
   1203          static ZStatus_t zclClosures_ProcessInDoorLockGetYearDaySchedule( zclIncoming_t *pInMsg,
   1204                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs )
   1205          {
   1206           if ( pCBs->pfnDoorLockGetYearDaySchedule )
   1207           {
   1208             zclDoorLockSchedule_t cmd;
   1209          
   1210             cmd.scheduleID = pInMsg->pData[0];
   1211             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1212          
   1213             return ( pCBs->pfnDoorLockGetYearDaySchedule( pInMsg, &cmd ) );
   1214           }
   1215          
   1216           return ( ZFailure );
   1217          }
   1218          
   1219          /*********************************************************************
   1220           * @fn      zclClosures_ProcessInDoorLockClearYearDaySchedule
   1221           *
   1222           * @brief   Process in the received Clear Year Day Schedule cmd
   1223           *
   1224           * @param   pInMsg - pointer to the incoming message
   1225           * @param   pCBs - pointer to the application callbacks
   1226           *
   1227           * @return  ZStatus_t
   1228           */
   1229          static ZStatus_t zclClosures_ProcessInDoorLockClearYearDaySchedule( zclIncoming_t *pInMsg,
   1230                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
   1231          {
   1232           if ( pCBs->pfnDoorLockClearYearDaySchedule )
   1233           {
   1234             zclDoorLockSchedule_t cmd;
   1235          
   1236             cmd.scheduleID = pInMsg->pData[0];
   1237             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1238          
   1239             return ( pCBs->pfnDoorLockClearYearDaySchedule( pInMsg, &cmd ) );
   1240           }
   1241          
   1242           return ( ZFailure );
   1243          }
   1244          
   1245          /*********************************************************************
   1246           * @fn      zclClosures_ProcessInDoorLockSetHolidaySchedule
   1247           *
   1248           * @brief   Process in the received Set Holiday Schedule cmd
   1249           *
   1250           * @param   pInMsg - pointer to the incoming message
   1251           * @param   pCBs - pointer to the application callbacks
   1252           *
   1253           * @return  ZStatus_t
   1254           */
   1255          static ZStatus_t zclClosures_ProcessInDoorLockSetHolidaySchedule( zclIncoming_t *pInMsg,
   1256                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs )
   1257          {
   1258           if ( pCBs->pfnDoorLockSetHolidaySchedule )
   1259           {
   1260             zclDoorLockSetHolidaySchedule_t cmd;
   1261          
   1262             cmd.holidayScheduleID = pInMsg->pData[0];
   1263             cmd.zigBeeLocalStartTime = BUILD_UINT32( pInMsg->pData[1], pInMsg->pData[2], pInMsg->pData[3], pInMsg->pData[4] );
   1264             cmd.zigBeeLocalEndTime = BUILD_UINT32( pInMsg->pData[5], pInMsg->pData[6], pInMsg->pData[7], pInMsg->pData[8] );
   1265             cmd.operatingModeDuringHoliday = pInMsg->pData[9];
   1266          
   1267             return ( pCBs->pfnDoorLockSetHolidaySchedule( pInMsg, &cmd ) );
   1268           }
   1269          
   1270           return ( ZFailure );
   1271          }
   1272          
   1273          /*********************************************************************
   1274           * @fn      zclClosures_ProcessInDoorLockGetHolidaySchedule
   1275           *
   1276           * @brief   Process in the received Get Holiday Schedule cmd
   1277           *
   1278           * @param   pInMsg - pointer to the incoming message
   1279           * @param   pCBs - pointer to the application callbacks
   1280           *
   1281           * @return  ZStatus_t
   1282           */
   1283          static ZStatus_t zclClosures_ProcessInDoorLockGetHolidaySchedule( zclIncoming_t *pInMsg,
   1284                                                                            zclClosures_DoorLockAppCallbacks_t *pCBs )
   1285          {
   1286           if ( pCBs->pfnDoorLockGetHolidaySchedule )
   1287           {
   1288             zclDoorLockHolidayScheduleID_t cmd;
   1289          
   1290             cmd.holidayScheduleID = pInMsg->pData[0];
   1291          
   1292             return ( pCBs->pfnDoorLockGetHolidaySchedule( pInMsg, &cmd ) );
   1293           }
   1294          
   1295           return ( ZFailure );
   1296          }
   1297          
   1298          /*********************************************************************
   1299           * @fn      zclClosures_ProcessInDoorLockClearHolidaySchedule
   1300           *
   1301           * @brief   Process in the received Clear Holiday Schedule cmd
   1302           *
   1303           * @param   pInMsg - pointer to the incoming message
   1304           * @param   pCBs - pointer to the application callbacks
   1305           *
   1306           * @return  ZStatus_t
   1307           */
   1308          static ZStatus_t zclClosures_ProcessInDoorLockClearHolidaySchedule( zclIncoming_t *pInMsg,
   1309                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
   1310          {
   1311           if ( pCBs->pfnDoorLockClearHolidaySchedule )
   1312           {
   1313             zclDoorLockHolidayScheduleID_t cmd;
   1314          
   1315             cmd.holidayScheduleID = pInMsg->pData[0];
   1316          
   1317             return ( pCBs->pfnDoorLockClearHolidaySchedule( pInMsg, &cmd ) );
   1318           }
   1319          
   1320           return ( ZFailure );
   1321          }
   1322          
   1323          /*********************************************************************
   1324           * @fn      zclClosures_ProcessInDoorLockSetUserType
   1325           *
   1326           * @brief   Process in the received Set User Type cmd
   1327           *
   1328           * @param   pInMsg - pointer to the incoming message
   1329           * @param   pCBs - pointer to the application callbacks
   1330           *
   1331           * @return  ZStatus_t
   1332           */
   1333          static ZStatus_t zclClosures_ProcessInDoorLockSetUserType( zclIncoming_t *pInMsg,
   1334                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs )
   1335          {
   1336           if ( pCBs->pfnDoorLockSetUserType )
   1337           {
   1338             zclDoorLockSetUserType_t cmd;
   1339          
   1340             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1341             cmd.userType = pInMsg->pData[2];
   1342          
   1343             return ( pCBs->pfnDoorLockSetUserType( pInMsg, &cmd ) );
   1344           }
   1345          
   1346           return ( ZFailure );
   1347          }
   1348          
   1349          /*********************************************************************
   1350           * @fn      zclClosures_ProcessInDoorLockGetUserType
   1351           *
   1352           * @brief   Process in the received Get User Type cmd
   1353           *
   1354           * @param   pInMsg - pointer to the incoming message
   1355           * @param   pCBs - pointer to the application callbacks
   1356           *
   1357           * @return  ZStatus_t
   1358           */
   1359          static ZStatus_t zclClosures_ProcessInDoorLockGetUserType( zclIncoming_t *pInMsg,
   1360                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs )
   1361          {
   1362           if ( pCBs->pfnDoorLockGetUserType )
   1363           {
   1364             zclDoorLockUserID_t cmd;
   1365          
   1366             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1367          
   1368             return ( pCBs->pfnDoorLockGetUserType( pInMsg, &cmd ) );
   1369           }
   1370          
   1371           return ( ZFailure );
   1372          }
   1373          
   1374          /*********************************************************************
   1375           * @fn      zclClosures_ProcessInDoorLockSetRFIDCode
   1376           *
   1377           * @brief   Process in the received Set RFID Code cmd
   1378           *
   1379           * @param   pInMsg - pointer to the incoming message
   1380           * @param   pCBs - pointer to the application callbacks
   1381           *
   1382           * @return  ZStatus_t
   1383           */
   1384          static ZStatus_t zclClosures_ProcessInDoorLockSetRFIDCode( zclIncoming_t *pInMsg,
   1385                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs )
   1386          {
   1387            ZStatus_t status;
   1388          
   1389            if ( pCBs->pfnDoorLockSetRFIDCode )
   1390            {
   1391              uint8 i;
   1392              uint8 offset;
   1393              uint8 calculatedArrayLen;
   1394              zclDoorLockSetRFIDCode_t cmd;
   1395          
   1396              // first octet of PIN/RFID Code variable string identifies its length
   1397              calculatedArrayLen = pInMsg->pData[4] + 1;  // add first byte of string
   1398          
   1399              cmd.pRfidCode = zcl_mem_alloc( calculatedArrayLen );
   1400              if ( !cmd.pRfidCode )
   1401              {
   1402                return ( ZMemError );  // no memory
   1403              }
   1404          
   1405              cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1406              cmd.userStatus = pInMsg->pData[2];
   1407              cmd.userType = pInMsg->pData[3];
   1408              offset = 4;
   1409              for ( i = 0; i < calculatedArrayLen; i++ )
   1410              {
   1411                cmd.pRfidCode[i] = pInMsg->pData[offset++];
   1412              }
   1413          
   1414              status = ( pCBs->pfnDoorLockSetRFIDCode( pInMsg, &cmd ) );
   1415              zcl_mem_free( cmd.pRfidCode );
   1416              return status;
   1417            }
   1418          
   1419           return ( ZFailure );
   1420          }
   1421          
   1422          /*********************************************************************
   1423           * @fn      zclClosures_ProcessInDoorLockGetRFIDCode
   1424           *
   1425           * @brief   Process in the received Get RFID Code cmd
   1426           *
   1427           * @param   pInMsg - pointer to the incoming message
   1428           * @param   pCBs - pointer to the application callbacks
   1429           *
   1430           * @return  ZStatus_t
   1431           */
   1432          static ZStatus_t zclClosures_ProcessInDoorLockGetRFIDCode( zclIncoming_t *pInMsg,
   1433                                                                     zclClosures_DoorLockAppCallbacks_t *pCBs )
   1434          {
   1435           if ( pCBs->pfnDoorLockGetRFIDCode )
   1436           {
   1437             zclDoorLockUserID_t cmd;
   1438          
   1439             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1440          
   1441             return ( pCBs->pfnDoorLockGetRFIDCode( pInMsg, &cmd ) );
   1442           }
   1443          
   1444           return ( ZFailure );
   1445          }
   1446          
   1447          /*********************************************************************
   1448           * @fn      zclClosures_ProcessInDoorLockClearRFIDCode
   1449           *
   1450           * @brief   Process in the received Clear RFID Code cmd
   1451           *
   1452           * @param   pInMsg - pointer to the incoming message
   1453           * @param   pCBs - pointer to the application callbacks
   1454           *
   1455           * @return  ZStatus_t
   1456           */
   1457          static ZStatus_t zclClosures_ProcessInDoorLockClearRFIDCode( zclIncoming_t *pInMsg,
   1458                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs )
   1459          {
   1460           if ( pCBs->pfnDoorLockClearRFIDCode )
   1461           {
   1462             zclDoorLockUserID_t cmd;
   1463          
   1464             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1465          
   1466             return ( pCBs->pfnDoorLockClearRFIDCode( pInMsg, &cmd ) );
   1467           }
   1468          
   1469           return ( ZFailure );
   1470          }
   1471          
   1472          /*********************************************************************
   1473           * @fn      zclClosures_ProcessInDoorLockClearAllRFIDCodes
   1474           *
   1475           * @brief   Process in the received Clear All RFID Codes cmd
   1476           *
   1477           * @param   pInMsg - pointer to the incoming message
   1478           * @param   pCBs - pointer to the application callbacks
   1479           *
   1480           * @return  ZStatus_t
   1481           */
   1482          static ZStatus_t zclClosures_ProcessInDoorLockClearAllRFIDCodes( zclIncoming_t *pInMsg,
   1483                                                                           zclClosures_DoorLockAppCallbacks_t *pCBs )
   1484          {
   1485           if ( pCBs->pfnDoorLockClearAllRFIDCodes )
   1486           {
   1487             // no payload
   1488          
   1489             return ( pCBs->pfnDoorLockClearAllRFIDCodes( pInMsg ) );
   1490           }
   1491          
   1492           return ( ZFailure );
   1493          }
   1494          
   1495          /*********************************************************************
   1496           * @fn      zclClosures_ProcessInDoorLockSetTemporaryPin
   1497           *
   1498           * @brief   Process in the received Set Temporary Pin cmd
   1499           *
   1500           * @param   pInMsg - pointer to the incoming message
   1501           * @param   pCBs - pointer to the application callbacks
   1502           *
   1503           * @return  ZStatus_t
   1504           */
   1505          static ZStatus_t zclClosures_ProcessInDoorLockSetTemporaryPin( zclIncoming_t *pInMsg,
   1506                                                                         zclClosures_DoorLockAppCallbacks_t *pCBs )
   1507          {
   1508            ZStatus_t status;
   1509            uint8 i,j;
   1510            uint8 offset = 0;
   1511          
   1512            if ( pCBs->pfnDoorLockSetTemporaryPin )
   1513            {
   1514              zclDoorLockSetTemporaryPin_t cmd;
   1515          
   1516              // adminPin
   1517              j = offset;
   1518              cmd.adminPin = (uint8 *)zcl_mem_alloc( pInMsg->pData[j] + 1 );
   1519              if ( !cmd.adminPin )
   1520              {
   1521                return ( ZMemError );  // no memory
   1522              }
   1523              for ( i=0; i<pInMsg->pData[j]+1; i++ )
   1524              {
   1525                cmd.adminPin[i] = pInMsg->pData[offset++];
   1526              }
   1527          
   1528              // tempPin
   1529              j = offset;
   1530              cmd.tempPin = (uint8 *)zcl_mem_alloc( pInMsg->pData[j] + 1 );
   1531              if ( !cmd.tempPin )
   1532              {
   1533                zcl_mem_free( cmd.adminPin );
   1534                return ( ZMemError );  // no memory
   1535              }
   1536              for ( i=0; i<pInMsg->pData[j]+1; i++ )
   1537              {
   1538                cmd.tempPin[i] = pInMsg->pData[offset++];
   1539              }
   1540          
   1541              // activeTimes
   1542              cmd.activeTimes = pInMsg->pData[offset++];
   1543          
   1544              // activeTime
   1545              cmd.activeTime = BUILD_UINT32( pInMsg->pData[offset], pInMsg->pData[offset+1], pInMsg->pData[offset+2], pInMsg->pData[offset+3] );
   1546          
   1547              status = ( pCBs->pfnDoorLockSetTemporaryPin( pInMsg, &cmd ) );
   1548              zcl_mem_free( cmd.tempPin );
   1549              zcl_mem_free( cmd.adminPin );
   1550              return status;
   1551            }
   1552          
   1553            return ( ZFailure );
   1554          }
   1555          
   1556          /*********************************************************************
   1557           * @fn      zclClosures_ModifyPin
   1558           *
   1559           * @brief   Process in the received Modify Pin cmd
   1560           *
   1561           * @param   pInMsg - pointer to the incoming message
   1562           * @param   pCBs - pointer to the application callbacks
   1563           *
   1564           * @return  ZStatus_t
   1565           */
   1566          static ZStatus_t zclClosures_ModifyPin( zclIncoming_t *pInMsg,
   1567                                                      zclClosures_DoorLockAppCallbacks_t *pCBs )
   1568          {
   1569            if ( pCBs->pfnDoorLockModifyPin )
   1570            {
   1571              zclDoorLockModifyPin_t cmd;
   1572              uint8 count,num = 0;
   1573              
   1574              for(count=0;count<PIN_LEN_MAX;count++)
   1575              {
   1576                cmd.OriginalPin[count] = pInMsg->pData[num++];
   1577              }
   1578              
   1579              for(count=0;count<PIN_LEN_MAX;count++)
   1580              {
   1581                cmd.ModifyPin[count] = pInMsg->pData[num++];
   1582              }
   1583              
   1584              return ( pCBs->pfnDoorLockModifyPin( pInMsg, &cmd ) );
   1585            }
   1586            
   1587            return ( ZFailure );
   1588          }
   1589          
   1590          /*********************************************************************
   1591           * @fn      zclClosures_ProcessInDoorLockUnlockWithTimeoutRsp
   1592           *
   1593           * @brief   Process in the received Unlock With Timeout Response cmd
   1594           *
   1595           * @param   pInMsg - pointer to the incoming message
   1596           * @param   pCBs - pointer to the application callbacks
   1597           *
   1598           * @return  ZStatus_t
   1599           */
   1600          static ZStatus_t zclClosures_ProcessInDoorLockUnlockWithTimeoutRsp( zclIncoming_t *pInMsg,
   1601                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
   1602          {
   1603           if ( pCBs->pfnDoorLockUnlockWithTimeoutRsp )
   1604           {
   1605             return ( pCBs->pfnDoorLockUnlockWithTimeoutRsp( pInMsg, pInMsg->pData[0] ) );
   1606           }
   1607          
   1608           return ( ZFailure );
   1609          }
   1610          
   1611          /*********************************************************************
   1612           * @fn      zclClosures_ProcessInDoorLockGetLogRecordRsp
   1613           *
   1614           * @brief   Process in the received Get Log Record Response cmd
   1615           *
   1616           * @param   pInMsg - pointer to the incoming message
   1617           * @param   pCBs - pointer to the application callbacks
   1618           *
   1619           * @return  ZStatus_t
   1620           */
   1621          static ZStatus_t zclClosures_ProcessInDoorLockGetLogRecordRsp( zclIncoming_t *pInMsg,
   1622                                                                         zclClosures_DoorLockAppCallbacks_t *pCBs )
   1623          {
   1624            ZStatus_t status;
   1625          
   1626            if ( pCBs->pfnDoorLockGetLogRecordRsp )
   1627            {
   1628              uint8 i;
   1629              uint8 offset;
   1630              uint8 calculatedArrayLen;
   1631              zclDoorLockGetLogRecordRsp_t cmd;
   1632          
   1633              // first octet of PIN/RFID Code variable string identifies its length
   1634              calculatedArrayLen = pInMsg->pData[11] + 1;  // add first byte of string
   1635          
   1636              cmd.pPIN = zcl_mem_alloc( calculatedArrayLen );
   1637              if ( !cmd.pPIN )
   1638              {
   1639                return ( ZMemError );  // no memory
   1640              }
   1641          
   1642              cmd.logEntryID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1643              cmd.timestamp = BUILD_UINT32( pInMsg->pData[2], pInMsg->pData[3], pInMsg->pData[4], pInMsg->pData[5] );
   1644              cmd.eventType = pInMsg->pData[6];
   1645              cmd.source = pInMsg->pData[7];
   1646              cmd.eventIDAlarmCode = pInMsg->pData[8];
   1647              cmd.userID = BUILD_UINT16( pInMsg->pData[9], pInMsg->pData[10] );
   1648              offset = 11;
   1649              for ( i = 0; i < calculatedArrayLen; i++ )
   1650              {
   1651                cmd.pPIN[i] = pInMsg->pData[offset++];
   1652              }
   1653          
   1654              status = ( pCBs->pfnDoorLockGetLogRecordRsp( pInMsg, &cmd ) );
   1655              zcl_mem_free( cmd.pPIN );
   1656              return status;
   1657            }
   1658          
   1659           return ( ZFailure );
   1660          }
   1661          
   1662          /*********************************************************************
   1663           * @fn      zclClosures_ProcessInDoorLockSetPINCodeRsp
   1664           *
   1665           * @brief   Process in the received Set PIN Code Response cmd
   1666           *
   1667           * @param   pInMsg - pointer to the incoming message
   1668           * @param   pCBs - pointer to the application callbacks
   1669           *
   1670           * @return  ZStatus_t
   1671           */
   1672          static ZStatus_t zclClosures_ProcessInDoorLockSetPINCodeRsp( zclIncoming_t *pInMsg,
   1673                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs )
   1674          {
   1675           if ( pCBs->pfnDoorLockSetPINCodeRsp )
   1676           {
   1677             return ( pCBs->pfnDoorLockSetPINCodeRsp( pInMsg, pInMsg->pData[0] ) );
   1678           }
   1679          
   1680           return ( ZFailure );
   1681          }
   1682          
   1683          /*********************************************************************
   1684           * @fn      zclClosures_ProcessInDoorLockGetPINCodeRsp
   1685           *
   1686           * @brief   Process in the received Get PIN Code Response cmd
   1687           *
   1688           * @param   pInMsg - pointer to the incoming message
   1689           * @param   pCBs - pointer to the application callbacks
   1690           *
   1691           * @return  ZStatus_t
   1692           */
   1693          static ZStatus_t zclClosures_ProcessInDoorLockGetPINCodeRsp( zclIncoming_t *pInMsg,
   1694                                                                       zclClosures_DoorLockAppCallbacks_t *pCBs )
   1695          {
   1696            ZStatus_t status;
   1697          
   1698            if ( pCBs->pfnDoorLockGetPINCodeRsp )
   1699            {
   1700              uint8 i;
   1701              uint8 offset;
   1702              uint8 calculatedArrayLen;
   1703              zclDoorLockGetPINCodeRsp_t cmd;
   1704          
   1705              // first octet of PIN/RFID Code variable string identifies its length
   1706              calculatedArrayLen = pInMsg->pData[4] + 1; // add first byte of string
   1707          
   1708              cmd.pCode = zcl_mem_alloc( calculatedArrayLen );
   1709              if ( !cmd.pCode )
   1710              {
   1711                return ( ZMemError );  // no memory
   1712              }
   1713          
   1714              cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1715              cmd.userStatus = pInMsg->pData[2];
   1716              cmd.userType = pInMsg->pData[3];
   1717              offset = 4;
   1718              for ( i = 0; i < calculatedArrayLen; i++ )
   1719              {
   1720                cmd.pCode[i] = pInMsg->pData[offset++];
   1721              }
   1722          
   1723              status = ( pCBs->pfnDoorLockGetPINCodeRsp( pInMsg, &cmd ) );
   1724              zcl_mem_free( cmd.pCode );
   1725              return status;
   1726            }
   1727          
   1728           return ( ZFailure );
   1729          }
   1730          
   1731          /*********************************************************************
   1732           * @fn      zclClosures_ProcessInDoorLockClearPINCodeRsp
   1733           *
   1734           * @brief   Process in the received Clear PIN Code Response cmd
   1735           *
   1736           * @param   pInMsg - pointer to the incoming message
   1737           * @param   pCBs - pointer to the application callbacks
   1738           *
   1739           * @return  ZStatus_t
   1740           */
   1741          static ZStatus_t zclClosures_ProcessInDoorLockClearPINCodeRsp( zclIncoming_t *pInMsg,
   1742                                                                         zclClosures_DoorLockAppCallbacks_t *pCBs )
   1743          {
   1744           if ( pCBs->pfnDoorLockClearPINCodeRsp )
   1745           {
   1746             return ( pCBs->pfnDoorLockClearPINCodeRsp( pInMsg, pInMsg->pData[0] ) );
   1747           }
   1748          
   1749           return ( ZFailure );
   1750          }
   1751          
   1752          /*********************************************************************
   1753           * @fn      zclClosures_ProcessInDoorLockClearAllPINCodesRsp
   1754           *
   1755           * @brief   Process in the received Clear All PIN Codes Response cmd
   1756           *
   1757           * @param   pInMsg - pointer to the incoming message
   1758           * @param   pCBs - pointer to the application callbacks
   1759           *
   1760           * @return  ZStatus_t
   1761           */
   1762          static ZStatus_t zclClosures_ProcessInDoorLockClearAllPINCodesRsp( zclIncoming_t *pInMsg,
   1763                                                                             zclClosures_DoorLockAppCallbacks_t *pCBs )
   1764          {
   1765           if ( pCBs->pfnDoorLockClearAllPINCodesRsp )
   1766           {
   1767             return ( pCBs->pfnDoorLockClearAllPINCodesRsp( pInMsg, pInMsg->pData[0] ) );
   1768           }
   1769          
   1770           return ( ZFailure );
   1771          }
   1772          
   1773          /*********************************************************************
   1774           * @fn      zclClosures_ProcessInDoorLockSetUserStatusRsp
   1775           *
   1776           * @brief   Process in the received Set User Status Response cmd
   1777           *
   1778           * @param   pInMsg - pointer to the incoming message
   1779           * @param   pCBs - pointer to the application callbacks
   1780           *
   1781           * @return  ZStatus_t
   1782           */
   1783          static ZStatus_t zclClosures_ProcessInDoorLockSetUserStatusRsp( zclIncoming_t *pInMsg,
   1784                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs )
   1785          {
   1786           if ( pCBs->pfnDoorLockSetUserStatusRsp )
   1787           {
   1788             return ( pCBs->pfnDoorLockSetUserStatusRsp( pInMsg, pInMsg->pData[0] ) );
   1789           }
   1790          
   1791           return ( ZFailure );
   1792          }
   1793          
   1794          /*********************************************************************
   1795           * @fn      zclClosures_ProcessInDoorLockGetUserStatusRsp
   1796           *
   1797           * @brief   Process in the received Get User Status Response cmd
   1798           *
   1799           * @param   pInMsg - pointer to the incoming message
   1800           * @param   pCBs - pointer to the application callbacks
   1801           *
   1802           * @return  ZStatus_t
   1803           */
   1804          static ZStatus_t zclClosures_ProcessInDoorLockGetUserStatusRsp( zclIncoming_t *pInMsg,
   1805                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs )
   1806          {
   1807           if ( pCBs->pfnDoorLockGetUserStatusRsp )
   1808           {
   1809             zclDoorLockGetUserStatusRsp_t cmd;
   1810          
   1811             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1812             cmd.userStatus = pInMsg->pData[2];
   1813          
   1814             return ( pCBs->pfnDoorLockGetUserStatusRsp( pInMsg, &cmd ) );
   1815           }
   1816          
   1817           return ( ZFailure );
   1818          }
   1819          
   1820          /*********************************************************************
   1821           * @fn      zclClosures_ProcessInDoorLockSetWeekDayScheduleRsp
   1822           *
   1823           * @brief   Process in the received Set Week Day Schedule Response cmd
   1824           *
   1825           * @param   pInMsg - pointer to the incoming message
   1826           * @param   pCBs - pointer to the application callbacks
   1827           *
   1828           * @return  ZStatus_t
   1829           */
   1830          static ZStatus_t zclClosures_ProcessInDoorLockSetWeekDayScheduleRsp( zclIncoming_t *pInMsg,
   1831                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs )
   1832          {
   1833           if ( pCBs->pfnDoorLockSetWeekDayScheduleRsp )
   1834           {
   1835             return ( pCBs->pfnDoorLockSetWeekDayScheduleRsp( pInMsg, pInMsg->pData[0] ) );
   1836           }
   1837          
   1838           return ( ZFailure );
   1839          }
   1840          
   1841          /*********************************************************************
   1842           * @fn      zclClosures_ProcessInDoorLockGetWeekDayScheduleRsp
   1843           *
   1844           * @brief   Process in the received Get Week Day Schedule Response cmd
   1845           *
   1846           * @param   pInMsg - pointer to the incoming message
   1847           * @param   pCBs - pointer to the application callbacks
   1848           *
   1849           * @return  ZStatus_t
   1850           */
   1851          static ZStatus_t zclClosures_ProcessInDoorLockGetWeekDayScheduleRsp( zclIncoming_t *pInMsg,
   1852                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs )
   1853          {
   1854           if ( pCBs->pfnDoorLockGetWeekDayScheduleRsp )
   1855           {
   1856             zclDoorLockGetWeekDayScheduleRsp_t cmd;
   1857          
   1858             cmd.scheduleID = pInMsg->pData[0];
   1859             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1860             cmd.status = pInMsg->pData[3];
   1861          
   1862             if ( cmd.status == ZCL_STATUS_SUCCESS )
   1863             {
   1864               cmd.daysMask = pInMsg->pData[4];
   1865               cmd.startHour = pInMsg->pData[5];
   1866               cmd.startMinute = pInMsg->pData[6];
   1867               cmd.endHour = pInMsg->pData[7];
   1868               cmd.endMinute = pInMsg->pData[8];
   1869             }
   1870          
   1871             return ( pCBs->pfnDoorLockGetWeekDayScheduleRsp( pInMsg, &cmd ) );
   1872           }
   1873          
   1874           return ( ZFailure );
   1875          }
   1876          
   1877          /*********************************************************************
   1878           * @fn      zclClosures_ProcessInDoorLockClearWeekDayScheduleRsp
   1879           *
   1880           * @brief   Process in the received Clear Week Day Schedule Response cmd
   1881           *
   1882           * @param   pInMsg - pointer to the incoming message
   1883           * @param   pCBs - pointer to the application callbacks
   1884           *
   1885           * @return  ZStatus_t
   1886           */
   1887          static ZStatus_t zclClosures_ProcessInDoorLockClearWeekDayScheduleRsp( zclIncoming_t *pInMsg,
   1888                                                                                 zclClosures_DoorLockAppCallbacks_t *pCBs )
   1889          {
   1890           if ( pCBs->pfnDoorLockClearWeekDayScheduleRsp )
   1891           {
   1892             return ( pCBs->pfnDoorLockClearWeekDayScheduleRsp( pInMsg, pInMsg->pData[0] ) );
   1893           }
   1894          
   1895           return ( ZFailure );
   1896          }
   1897          
   1898          /*********************************************************************
   1899           * @fn      zclClosures_ProcessInDoorLockSetYearDayScheduleRsp
   1900           *
   1901           * @brief   Process in the received Set Year Day Schedule Response cmd
   1902           *
   1903           * @param   pInMsg - pointer to the incoming message
   1904           * @param   pCBs - pointer to the application callbacks
   1905           *
   1906           * @return  ZStatus_t
   1907           */
   1908          static ZStatus_t zclClosures_ProcessInDoorLockSetYearDayScheduleRsp( zclIncoming_t *pInMsg,
   1909                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs )
   1910          {
   1911           if ( pCBs->pfnDoorLockSetYearDayScheduleRsp )
   1912           {
   1913             return ( pCBs->pfnDoorLockSetYearDayScheduleRsp( pInMsg, pInMsg->pData[0] ) );
   1914           }
   1915          
   1916           return ( ZFailure );
   1917          }
   1918          
   1919          /*********************************************************************
   1920           * @fn      zclClosures_ProcessInDoorLockGetYearDayScheduleRsp
   1921           *
   1922           * @brief   Process in the received Get Year Day Schedule Response cmd
   1923           *
   1924           * @param   pInMsg - pointer to the incoming message
   1925           * @param   pCBs - pointer to the application callbacks
   1926           *
   1927           * @return  ZStatus_t
   1928           */
   1929          static ZStatus_t zclClosures_ProcessInDoorLockGetYearDayScheduleRsp( zclIncoming_t *pInMsg,
   1930                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs )
   1931          {
   1932           if ( pCBs->pfnDoorLockGetYearDayScheduleRsp )
   1933           {
   1934             zclDoorLockGetYearDayScheduleRsp_t cmd;
   1935          
   1936             cmd.scheduleID = pInMsg->pData[0];
   1937             cmd.userID = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   1938             cmd.status = pInMsg->pData[3];
   1939          
   1940             if ( cmd.status == ZCL_STATUS_SUCCESS )
   1941             {
   1942               cmd.zigBeeLocalStartTime = BUILD_UINT32( pInMsg->pData[4], pInMsg->pData[5], pInMsg->pData[6], pInMsg->pData[7] );
   1943               cmd.zigBeeLocalEndTime = BUILD_UINT32( pInMsg->pData[8], pInMsg->pData[9], pInMsg->pData[10], pInMsg->pData[11] );
   1944             }
   1945          
   1946             return ( pCBs->pfnDoorLockGetYearDayScheduleRsp( pInMsg, &cmd ) );
   1947           }
   1948          
   1949           return ( ZFailure );
   1950          }
   1951          
   1952          /*********************************************************************
   1953           * @fn      zclClosures_ProcessInDoorLockClearYearDayScheduleRsp
   1954           *
   1955           * @brief   Process in the received Clear Year Day Schedule Response cmd
   1956           *
   1957           * @param   pInMsg - pointer to the incoming message
   1958           * @param   pCBs - pointer to the application callbacks
   1959           *
   1960           * @return  ZStatus_t
   1961           */
   1962          static ZStatus_t zclClosures_ProcessInDoorLockClearYearDayScheduleRsp( zclIncoming_t *pInMsg,
   1963                                                                                 zclClosures_DoorLockAppCallbacks_t *pCBs )
   1964          {
   1965           if ( pCBs->pfnDoorLockClearYearDayScheduleRsp )
   1966           {
   1967             return ( pCBs->pfnDoorLockClearYearDayScheduleRsp( pInMsg, pInMsg->pData[0] ) );
   1968           }
   1969          
   1970           return ( ZFailure );
   1971          }
   1972          
   1973          /*********************************************************************
   1974           * @fn      zclClosures_ProcessInDoorLockSetHolidayScheduleRsp
   1975           *
   1976           * @brief   Process in the received Set Holiday Schedule Response cmd
   1977           *
   1978           * @param   pInMsg - pointer to the incoming message
   1979           * @param   pCBs - pointer to the application callbacks
   1980           *
   1981           * @return  ZStatus_t
   1982           */
   1983          static ZStatus_t zclClosures_ProcessInDoorLockSetHolidayScheduleRsp( zclIncoming_t *pInMsg,
   1984                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs )
   1985          {
   1986           if ( pCBs->pfnDoorLockSetHolidayScheduleRsp )
   1987           {
   1988             return ( pCBs->pfnDoorLockSetHolidayScheduleRsp( pInMsg, pInMsg->pData[0] ) );
   1989           }
   1990          
   1991           return ( ZFailure );
   1992          }
   1993          
   1994          /*********************************************************************
   1995           * @fn      zclClosures_ProcessInDoorLockGetHolidayScheduleRsp
   1996           *
   1997           * @brief   Process in the received Get Holiday Schedule Response cmd
   1998           *
   1999           * @param   pInMsg - pointer to the incoming message
   2000           * @param   pCBs - pointer to the application callbacks
   2001           *
   2002           * @return  ZStatus_t
   2003           */
   2004          static ZStatus_t zclClosures_ProcessInDoorLockGetHolidayScheduleRsp( zclIncoming_t *pInMsg,
   2005                                                                               zclClosures_DoorLockAppCallbacks_t *pCBs )
   2006          {
   2007           if ( pCBs->pfnDoorLockGetHolidayScheduleRsp )
   2008           {
   2009             zclDoorLockGetHolidayScheduleRsp_t cmd;
   2010          
   2011             cmd.holidayScheduleID = pInMsg->pData[0];
   2012             cmd.status = pInMsg->pData[1];
   2013          
   2014             if ( cmd.status == ZCL_STATUS_SUCCESS )
   2015             {
   2016               cmd.zigBeeLocalStartTime = BUILD_UINT32( pInMsg->pData[2], pInMsg->pData[3], pInMsg->pData[4], pInMsg->pData[5] );
   2017               cmd.zigBeeLocalEndTime = BUILD_UINT32( pInMsg->pData[6], pInMsg->pData[7], pInMsg->pData[8], pInMsg->pData[9] );
   2018               cmd.operatingModeDuringHoliday = pInMsg->pData[10];
   2019             }
   2020          
   2021             return ( pCBs->pfnDoorLockGetHolidayScheduleRsp( pInMsg, &cmd ) );
   2022           }
   2023          
   2024           return ( ZFailure );
   2025          }
   2026          
   2027          /*********************************************************************
   2028           * @fn      zclClosures_ProcessInDoorLockClearHolidayScheduleRsp
   2029           *
   2030           * @brief   Process in the received Clear Holiday Schedule Response cmd
   2031           *
   2032           * @param   pInMsg - pointer to the incoming message
   2033           * @param   pCBs - pointer to the application callbacks
   2034           *
   2035           * @return  ZStatus_t
   2036           */
   2037          static ZStatus_t zclClosures_ProcessInDoorLockClearHolidayScheduleRsp( zclIncoming_t *pInMsg,
   2038                                                                                 zclClosures_DoorLockAppCallbacks_t *pCBs )
   2039          {
   2040           if ( pCBs->pfnDoorLockClearHolidayScheduleRsp )
   2041           {
   2042             return ( pCBs->pfnDoorLockClearHolidayScheduleRsp( pInMsg, pInMsg->pData[0] ) );
   2043           }
   2044          
   2045           return ( ZFailure );
   2046          }
   2047          
   2048          /*********************************************************************
   2049           * @fn      zclClosures_ProcessInDoorLockSetUserTypeRsp
   2050           *
   2051           * @brief   Process in the received Set User Type Response cmd
   2052           *
   2053           * @param   pInMsg - pointer to the incoming message
   2054           * @param   pCBs - pointer to the application callbacks
   2055           *
   2056           * @return  ZStatus_t
   2057           */
   2058          static ZStatus_t zclClosures_ProcessInDoorLockSetUserTypeRsp( zclIncoming_t *pInMsg,
   2059                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs )
   2060          {
   2061           if ( pCBs->pfnDoorLockSetUserTypeRsp )
   2062           {
   2063             return ( pCBs->pfnDoorLockSetUserTypeRsp( pInMsg, pInMsg->pData[0] ) );
   2064           }
   2065          
   2066           return ( ZFailure );
   2067          }
   2068          
   2069          /*********************************************************************
   2070           * @fn      zclClosures_ProcessInDoorLockGetUserTypeRsp
   2071           *
   2072           * @brief   Process in the received Get User Type Response cmd
   2073           *
   2074           * @param   pInMsg - pointer to the incoming message
   2075           * @param   pCBs - pointer to the application callbacks
   2076           *
   2077           * @return  ZStatus_t
   2078           */
   2079          static ZStatus_t zclClosures_ProcessInDoorLockGetUserTypeRsp( zclIncoming_t *pInMsg,
   2080                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs )
   2081          {
   2082           if ( pCBs->pfnDoorLockGetUserTypeRsp )
   2083           {
   2084             zclDoorLockGetUserTypeRsp_t cmd;
   2085          
   2086             cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   2087             cmd.userType = pInMsg->pData[2];
   2088          
   2089             return ( pCBs->pfnDoorLockGetUserTypeRsp( pInMsg, &cmd ) );
   2090           }
   2091          
   2092           return ( ZFailure );
   2093          }
   2094          
   2095          /*********************************************************************
   2096           * @fn      zclClosures_ProcessInDoorLockSetRFIDCodeRsp
   2097           *
   2098           * @brief   Process in the received Set RFID Code Response cmd
   2099           *
   2100           * @param   pInMsg - pointer to the incoming message
   2101           * @param   pCBs - pointer to the application callbacks
   2102           *
   2103           * @return  ZStatus_t
   2104           */
   2105          static ZStatus_t zclClosures_ProcessInDoorLockSetRFIDCodeRsp( zclIncoming_t *pInMsg,
   2106                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs )
   2107          {
   2108           if ( pCBs->pfnDoorLockSetRFIDCodeRsp )
   2109           {
   2110             return ( pCBs->pfnDoorLockSetRFIDCodeRsp( pInMsg, pInMsg->pData[0] ) );
   2111           }
   2112          
   2113           return ( ZFailure );
   2114          }
   2115          
   2116          /*********************************************************************
   2117           * @fn      zclClosures_ProcessInDoorLockGetRFIDCodeRsp
   2118           *
   2119           * @brief   Process in the received Get RFID Code Response cmd
   2120           *
   2121           * @param   pInMsg - pointer to the incoming message
   2122           * @param   pCBs - pointer to the application callbacks
   2123           *
   2124           * @return  ZStatus_t
   2125           */
   2126          static ZStatus_t zclClosures_ProcessInDoorLockGetRFIDCodeRsp( zclIncoming_t *pInMsg,
   2127                                                                        zclClosures_DoorLockAppCallbacks_t *pCBs )
   2128          {
   2129            ZStatus_t status;
   2130          
   2131            if ( pCBs->pfnDoorLockGetRFIDCodeRsp )
   2132            {
   2133              uint8 i;
   2134              uint8 offset;
   2135              uint8 calculatedArrayLen;
   2136              zclDoorLockGetRFIDCodeRsp_t cmd;
   2137          
   2138              // first octet of PIN/RFID Code variable string identifies its length
   2139              calculatedArrayLen = pInMsg->pData[4] + 1; // add first byte of string
   2140          
   2141              cmd.pRfidCode = zcl_mem_alloc( calculatedArrayLen );
   2142              if ( !cmd.pRfidCode )
   2143              {
   2144                return ( ZMemError );  // no memory
   2145              }
   2146          
   2147              cmd.userID = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   2148              cmd.userStatus = pInMsg->pData[2];
   2149              cmd.userType = pInMsg->pData[3];
   2150              offset = 4;
   2151              for ( i = 0; i < calculatedArrayLen; i++ )
   2152              {
   2153                cmd.pRfidCode[i] = pInMsg->pData[offset++];
   2154              }
   2155          
   2156              status = ( pCBs->pfnDoorLockGetRFIDCodeRsp( pInMsg, &cmd ) );
   2157              zcl_mem_free( cmd.pRfidCode );
   2158              return status;
   2159            }
   2160          
   2161           return ( ZFailure );
   2162          }
   2163          
   2164          /*********************************************************************
   2165           * @fn      zclClosures_ProcessInDoorLockClearRFIDCodeRsp
   2166           *
   2167           * @brief   Process in the received Clear RFID Code Response cmd
   2168           *
   2169           * @param   pInMsg - pointer to the incoming message
   2170           * @param   pCBs - pointer to the application callbacks
   2171           *
   2172           * @return  ZStatus_t
   2173           */
   2174          static ZStatus_t zclClosures_ProcessInDoorLockClearRFIDCodeRsp( zclIncoming_t *pInMsg,
   2175                                                                          zclClosures_DoorLockAppCallbacks_t *pCBs )
   2176          {
   2177           if ( pCBs->pfnDoorLockClearRFIDCodeRsp )
   2178           {
   2179             return ( pCBs->pfnDoorLockClearRFIDCodeRsp( pInMsg, pInMsg->pData[0] ) );
   2180           }
   2181          
   2182           return ( ZFailure );
   2183          }
   2184          
   2185          /*********************************************************************
   2186           * @fn      zclClosures_ProcessInDoorLockClearAllRFIDCodesRsp
   2187           *
   2188           * @brief   Process in the received Clear All RFID Codes Response cmd
   2189           *
   2190           * @param   pInMsg - pointer to the incoming message
   2191           * @param   pCBs - pointer to the application callbacks
   2192           *
   2193           * @return  ZStatus_t
   2194           */
   2195          static ZStatus_t zclClosures_ProcessInDoorLockClearAllRFIDCodesRsp( zclIncoming_t *pInMsg,
   2196                                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
   2197          {
   2198           if ( pCBs->pfnDoorLockClearAllRFIDCodesRsp )
   2199           {
   2200             return ( pCBs->pfnDoorLockClearAllRFIDCodesRsp( pInMsg, pInMsg->pData[0] ) );
   2201           }
   2202          
   2203           return ( ZFailure );
   2204          }
   2205          
   2206          /*********************************************************************
   2207           * @fn      zclClosures_ProcessInDoorLockOperationEventNotification
   2208           *
   2209           * @brief   Process in the received Operation Event Notification cmd
   2210           *
   2211           * @param   pInMsg - pointer to the incoming message
   2212           * @param   pCBs - pointer to the application callbacks
   2213           *
   2214           * @return  ZStatus_t
   2215           */
   2216          static ZStatus_t zclClosures_ProcessInDoorLockOperationEventNotification( zclIncoming_t *pInMsg,
   2217                                                                                    zclClosures_DoorLockAppCallbacks_t *pCBs )
   2218          {
   2219            uint8 i;
   2220            uint8 offset;
   2221            uint8 calculatedArrayLen;
   2222            zclDoorLockOperationEventNotification_t cmd;
   2223            ZStatus_t status;
   2224          
   2225           if ( pCBs->pfnDoorLockOperationEventNotification )
   2226           {
   2227              calculatedArrayLen = pInMsg->pData[9] + 1;  // add first byte of string
   2228          
   2229              cmd.pData = zcl_mem_alloc( calculatedArrayLen );
   2230              if ( !cmd.pData )
   2231              {
   2232                return ( ZMemError );  // no memory
   2233              }
   2234          
   2235              cmd.operationEventSource = pInMsg->pData[0];
   2236              cmd.operationEventCode = pInMsg->pData[1];
   2237              cmd.userID = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2238              cmd.pin = pInMsg->pData[4];
   2239              cmd.zigBeeLocalTime = BUILD_UINT32( pInMsg->pData[5], pInMsg->pData[6], pInMsg->pData[7], pInMsg->pData[8] );
   2240              offset = 9;
   2241              for ( i = 0; i < calculatedArrayLen; i++ )
   2242              {
   2243                cmd.pData[i] = pInMsg->pData[offset++];
   2244              }
   2245          
   2246              status = ( pCBs->pfnDoorLockOperationEventNotification( pInMsg, &cmd ) );
   2247              zcl_mem_free( cmd.pData );
   2248              return status;
   2249            }
   2250           return ( ZFailure );
   2251          }
   2252          
   2253          /*********************************************************************
   2254           * @fn      zclClosures_ProcessInDoorLockProgrammingEventNotification
   2255           *
   2256           * @brief   Process in the received Programming Event Notification cmd
   2257           *
   2258           * @param   pInMsg - pointer to the incoming message
   2259           * @param   pCBs - pointer to the application callbacks
   2260           *
   2261           * @return  ZStatus_t
   2262           */
   2263          static ZStatus_t zclClosures_ProcessInDoorLockProgrammingEventNotification( zclIncoming_t *pInMsg,
   2264                                                                                      zclClosures_DoorLockAppCallbacks_t *pCBs )
   2265          {
   2266            uint8 i;
   2267            uint8 offset;
   2268            uint8 calculatedArrayLen;
   2269            zclDoorLockProgrammingEventNotification_t cmd;
   2270            ZStatus_t status;
   2271          
   2272            if ( pCBs->pfnDoorLockProgrammingEventNotification )
   2273            {
   2274              calculatedArrayLen = pInMsg->pData[11] + 1; // add first byte of string
   2275          
   2276              cmd.pData = zcl_mem_alloc( calculatedArrayLen );
   2277              if ( !cmd.pData )
   2278              {
   2279                return ( ZMemError );  // no memory
   2280              }
   2281          
   2282              cmd.programEventSource = pInMsg->pData[0];
   2283              cmd.programEventCode = pInMsg->pData[1];
   2284              cmd.userID = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2285              cmd.pin = pInMsg->pData[4];
   2286              cmd.userType = pInMsg->pData[5];
   2287              cmd.userStatus = pInMsg->pData[6];
   2288              cmd.zigBeeLocalTime = BUILD_UINT32( pInMsg->pData[7], pInMsg->pData[8], pInMsg->pData[9], pInMsg->pData[10] );
   2289              offset = 11;
   2290              for ( i = 0; i < calculatedArrayLen; i++ )
   2291              {
   2292                cmd.pData[i] = pInMsg->pData[offset++];
   2293              }
   2294          
   2295              status = ( pCBs->pfnDoorLockProgrammingEventNotification( pInMsg, &cmd ) );
   2296              zcl_mem_free( cmd.pData );
   2297              return status;
   2298            }
   2299          
   2300           return ( ZFailure );
   2301          }
   2302          
   2303          #endif //ZCL_DOORLOCK_EXT
   2304          
   2305          /*********************************************************************
   2306           * @fn      zclClosures_SendDoorLockRequest
   2307           *
   2308           * @brief   Call to send out a Door Lock Lock/Unlock/Toggle Command
   2309           *
   2310           * @param   srcEP - Sending application's endpoint
   2311           * @param   dstAddr - where you want the message to go
   2312           * @param   cmd - COMMAND_CLOSURES_LOCK_DOOR, COMMAND_CLOSURES_UNLOCK_DOOR, COMMAND_CLOSURES_TOGGLE_DOOR
   2313           * @param   pPayload:
   2314           *           aPinRfidCode - PIN/RFID code in ZCL Octet String Format
   2315           * @param   disableDefaultRsp - decides default response is necessary or not
   2316           * @param   seqNum - sequence number of the command packet
   2317           *
   2318           * @return  ZStatus_t
   2319           */
   2320          ZStatus_t zclClosures_SendDoorLockRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   2321                                                     zclDoorLock_t *pPayload,
   2322                                                     uint8 disableDefaultRsp, uint8 seqNum )
   2323          {
   2324            uint8 i;
   2325            uint8 *pBuf;  // variable length payload
   2326            uint8 calculatedBufSize;
   2327            ZStatus_t status;
   2328          
   2329            // first octet of PIN/RFID Code variable string identifies its length
   2330            calculatedBufSize = pPayload->pPinRfidCode[0] + 1;  // add first byte of string
   2331          
   2332            pBuf = zcl_mem_alloc( calculatedBufSize );
   2333            if ( !pBuf )
   2334            {
   2335              return ( ZMemError );  // no memory
   2336            }
   2337          
   2338            // over-the-air is always little endian. Break into a byte stream.
   2339            for ( i = 0; i < calculatedBufSize; i++ )
   2340            {
   2341              pBuf[i] = pPayload->pPinRfidCode[i];
   2342            }
   2343          
   2344            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2345                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2346                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   2347            zcl_mem_free( pBuf );
   2348            return status;
   2349          }
   2350          
   2351          /*********************************************************************
   2352           * @fn      zclClosures_SendDoorLockUnlockTimeoutRequest
   2353           *
   2354           * @brief   Call to send out a Unlock with Timeout Command
   2355           *
   2356           * @param   srcEP - Sending application's endpoint
   2357           * @param   dstAddr - where you want the message to go
   2358           * @param   pPayload:
   2359           *           timeout - The timeout in seconds
   2360           *           aPinRfidCode - PIN/RFID code in ZCL Octet String Format
   2361           * @param   disableDefaultRsp - decides default response is necessary or not
   2362           * @param   seqNum - sequence number of the command packet
   2363           *
   2364           * @return  ZStatus_t
   2365           */
   2366          ZStatus_t zclClosures_SendDoorLockUnlockTimeoutRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2367                                                                  zclDoorLockUnlockTimeout_t *pPayload,
   2368                                                                  uint8 disableDefaultRsp, uint8 seqNum )
   2369          {
   2370            uint8 i;
   2371            uint8 *pBuf;  // variable length payload
   2372            uint8 offset;
   2373            uint8 calculatedArrayLen;
   2374            uint8 calculatedBufSize;
   2375            ZStatus_t status;
   2376          
   2377            // first octet of PIN/RFID Code variable string identifies its length
   2378            calculatedArrayLen = pPayload->pPinRfidCode[0] + 1;  // add first byte of string
   2379          
   2380            // determine total size of buffer
   2381            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_UNLOCK_TIMEOUT;
   2382          
   2383            pBuf = zcl_mem_alloc( calculatedBufSize );
   2384            if ( !pBuf )
   2385            {
   2386              return ( ZMemError );  // no memory
   2387            }
   2388          
   2389            // over-the-air is always little endian. Break into a byte stream.
   2390            pBuf[0] = LO_UINT16(pPayload->timeout);
   2391            pBuf[1] = HI_UINT16(pPayload->timeout);
   2392            offset = 2;
   2393            for ( i = 0; i < calculatedArrayLen; i++ )
   2394            {
   2395              pBuf[offset++] = pPayload->pPinRfidCode[i];
   2396            }
   2397          
   2398            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2399                                      COMMAND_CLOSURES_UNLOCK_WITH_TIMEOUT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2400                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   2401            zcl_mem_free( pBuf );
   2402            return status;
   2403          }
   2404          
   2405          /*********************************************************************
   2406           * @fn      zclClosures_SendDoorLockGetLogRecordRequest
   2407           *
   2408           * @brief   Call to send out a Get Log Record Command
   2409           *
   2410           * @param   srcEP - Sending application's endpoint
   2411           * @param   dstAddr - where you want the message to go
   2412           * @param   logIndex - Log number between 1 - [max log attribute]
   2413           * @param   disableDefaultRsp - decides default response is necessary or not
   2414           * @param   seqNum - sequence number of the command packet
   2415           *
   2416           * @return  ZStatus_t
   2417           */
   2418          ZStatus_t zclClosures_SendDoorLockGetLogRecordRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2419                                                                 uint16 logIndex, uint8 disableDefaultRsp, uint8 seqNum )
   2420          {
   2421            uint8 payload[PAYLOAD_LEN_GET_LOG_RECORD];
   2422          
   2423            payload[0] = LO_UINT16( logIndex );
   2424            payload[1] = HI_UINT16( logIndex );
   2425          
   2426            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2427                                    COMMAND_CLOSURES_GET_LOG_RECORD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2428                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_GET_LOG_RECORD, payload );
   2429          }
   2430          
   2431          /*********************************************************************
   2432           * @fn      zclClosures_SendDoorLockSetPINCodeRequest
   2433           *
   2434           * @brief   Call to send out a Set PIN Code Command
   2435           *
   2436           * @param   srcEP - Sending application's endpoint
   2437           * @param   dstAddr - where you want the message to go
   2438           * @param   pPayload:
   2439           *           userID - User ID is between 0 - [# PINs User supported attribute]
   2440           *           userStatus - Used to indicate what the status is for a specific User ID
   2441           *           userType - Used to indicate what the type is for a specific User ID
   2442           *           pPIN - A ZigBee string indicating the PIN code used to create the event on the door lock
   2443           * @param   disableDefaultRsp - decides default response is necessary or not
   2444           * @param   seqNum - sequence number of the command packet
   2445           *
   2446           * @return  ZStatus_t
   2447           */
   2448          ZStatus_t zclClosures_SendDoorLockSetPINCodeRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2449                                                               zclDoorLockSetPINCode_t *pPayload,
   2450                                                               uint8 disableDefaultRsp, uint8 seqNum )
   2451          {
   2452            uint8 i;
   2453            uint8 *pBuf;  // variable length payload
   2454            uint8 offset;
   2455            uint8 calculatedArrayLen;
   2456            uint8 calculatedBufSize;
   2457            ZStatus_t status;
   2458          
   2459            // first octet of PIN/RFID Code variable string identifies its length
   2460            calculatedArrayLen = pPayload->pPIN[0] + 1;  // add first byte of string
   2461          
   2462            // determine the total buffer size
   2463            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_SET_PIN_CODE;
   2464          
   2465            pBuf = zcl_mem_alloc( calculatedBufSize );
   2466            if ( !pBuf )
   2467            {
   2468              return ( ZMemError );  // no memory
   2469            }
   2470          
   2471            // over-the-air is always little endian. Break into a byte stream.
   2472            pBuf[0] = LO_UINT16(pPayload->userID);
   2473            pBuf[1] = HI_UINT16(pPayload->userID);
   2474            pBuf[2] = pPayload->userStatus;
   2475            pBuf[3] = pPayload->userType;
   2476            offset = 4;
   2477            for ( i = 0; i < calculatedArrayLen; i++ )
   2478            {
   2479              pBuf[offset++] = pPayload->pPIN[i];
   2480            }
   2481          
   2482          
   2483            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2484                                      COMMAND_CLOSURES_SET_PIN_CODE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2485                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   2486            zcl_mem_free( pBuf );
   2487            return status;
   2488          }
   2489          
   2490          /*********************************************************************
   2491           * @fn      zclClosures_SendDoorLockUserIDRequest
   2492           *
   2493           * @brief   Call to send out a User ID Command
   2494           *
   2495           * @param   srcEP - Sending application's endpoint
   2496           * @param   dstAddr - where you want the message to go
   2497           * @param   cmd - COMMAND_CLOSURES_GET_PIN_CODE, COMMAND_CLOSURES_CLEAR_PIN_CODE,
   2498           *                COMMAND_CLOSURES_GET_USER_STATUS, COMMAND_CLOSURES_GET_USER_TYPE,
   2499           *                COMMAND_CLOSURES_GET_RFID_CODE, COMMAND_CLOSURES_CLEAR_RFID_CODE
   2500           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   2501           * @param   disableDefaultRsp - decides default response is necessary or not
   2502           * @param   seqNum - sequence number of the command packet
   2503           *
   2504           * @return  ZStatus_t
   2505           */
   2506          ZStatus_t zclClosures_SendDoorLockUserIDRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   2507                                                           uint16 userID, uint8 disableDefaultRsp, uint8 seqNum )
   2508          {
   2509            uint8 payload[PAYLOAD_LEN_USER_ID];
   2510          
   2511            payload[0] = LO_UINT16(userID);
   2512            payload[1] = HI_UINT16(userID);
   2513          
   2514            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2515                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2516                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_USER_ID, payload );
   2517          }
   2518          
   2519          /*********************************************************************
   2520           * @fn      zclClosures_SendDoorLockClearAllCodesRequest
   2521           *
   2522           * @brief   Call to send out a Clear All Codes Command
   2523           *
   2524           * @param   srcEP - Sending application's endpoint
   2525           * @param   dstAddr - where you want the message to go
   2526           * @param   cmd - COMMAND_CLOSURES_CLEAR_ALL_PIN_CODES, COMMAND_CLOSURES_CLEAR_ALL_RFID_CODES
   2527           * @param   disableDefaultRsp - decides default response is necessary or not
   2528           * @param   seqNum - sequence number of the command packet
   2529           *
   2530           * @return  ZStatus_t
   2531           */
   2532          ZStatus_t zclClosures_SendDoorLockClearAllCodesRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   2533                                                                  uint8 disableDefaultRsp, uint8 seqNum )
   2534          {
   2535            // no payload
   2536          
   2537            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2538                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2539                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   2540          }
   2541          
   2542          /*********************************************************************
   2543           * @fn      zclClosures_SendDoorLockSetUserStatusRequest
   2544           *
   2545           * @brief   Call to send out a Set User Status Command
   2546           *
   2547           * @param   srcEP - Sending application's endpoint
   2548           * @param   dstAddr - where you want the message to go
   2549           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   2550           * @param   userStatus - Used to indicate what the status is for a specific User ID
   2551           * @param   disableDefaultRsp - decides default response is necessary or not
   2552           * @param   seqNum - sequence number of the command packet
   2553           *
   2554           * @return  ZStatus_t
   2555           */
   2556          ZStatus_t zclClosures_SendDoorLockSetUserStatusRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2557                                                                  uint16 userID, uint8 userStatus,
   2558                                                                  uint8 disableDefaultRsp, uint8 seqNum )
   2559          {
   2560            uint8 payload[PAYLOAD_LEN_SET_USER_STATUS];
   2561          
   2562            payload[0] = LO_UINT16(userID);
   2563            payload[1] = HI_UINT16(userID);
   2564            payload[2] = userStatus;
   2565          
   2566            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2567                                    COMMAND_CLOSURES_SET_USER_STATUS, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2568                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_SET_USER_STATUS, payload );
   2569          }
   2570          
   2571          /*********************************************************************
   2572           * @fn      zclClosures_SendDoorLockSetWeekDayScheduleRequest
   2573           *
   2574           * @brief   Call to send out a Set Week Day Schedule Command
   2575           *
   2576           * @param   srcEP - Sending application's endpoint
   2577           * @param   dstAddr - where you want the message to go
   2578           * @param   scheduleID - The Schedule ID # is between 0 - [# Schedule IDs per user attribute]
   2579           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   2580           * @param   daysMask - Bitmask of the effective days in the order XSFTWTMS
   2581           * @param   startHour - The start hour of the Week Day Schedule: 0-23
   2582           * @param   startMinute - The start minute of the Week Day Schedule: 0-59
   2583           * @param   endHour - The end hour of the Week Day Schedule: 0-23
   2584           * @param   endMinute - The end minute of the Week Day Schedule: 0-59
   2585           * @param   disableDefaultRsp - decides default response is necessary or not
   2586           * @param   seqNum - sequence number of the command packet
   2587           *
   2588           * @return  ZStatus_t
   2589           */
   2590          ZStatus_t zclClosures_SendDoorLockSetWeekDayScheduleRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2591                                                                       uint8 scheduleID, uint16 userID,
   2592                                                                       uint8 daysMask, uint8 startHour,
   2593                                                                       uint8 startMinute, uint8 endHour,
   2594                                                                       uint8 endMinute, uint8 disableDefaultRsp, uint8 seqNum )
   2595          {
   2596            uint8 payload[PAYLOAD_LEN_SET_WEEK_DAY_SCHEDULE];
   2597          
   2598            payload[0] = scheduleID;
   2599            payload[1] = LO_UINT16(userID);
   2600            payload[2] = HI_UINT16(userID);
   2601            payload[3] = daysMask;
   2602            payload[4] = startHour;
   2603            payload[5] = startMinute;
   2604            payload[6] = endHour;
   2605            payload[7] = endMinute;
   2606          
   2607            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2608                                    COMMAND_CLOSURES_SET_WEEK_DAY_SCHEDULE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2609                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_SET_WEEK_DAY_SCHEDULE, payload );
   2610          }
   2611          
   2612          /*********************************************************************
   2613           * @fn      zclClosures_SendDoorLockScheduleRequest
   2614           *
   2615           * @brief   Call to send out a Schedule Command
   2616           *
   2617           * @param   srcEP - Sending application's endpoint
   2618           * @param   dstAddr - where you want the message to go
   2619           * @param   cmd - COMMAND_CLOSURES_GET_WEEK_DAY_SCHEDULE, COMMAND_CLOSURES_CLEAR_WEEK_DAY_SCHEDULE,
   2620           *                COMMAND_CLOSURES_GET_YEAR_DAY_SCHEDULE, COMMAND_CLOSURES_CLEAR_YEAR_DAY_SCHEDULE
   2621           * @param   scheduleID - The Schedule ID # is between 0 - [# Schedule IDs per user attribute]
   2622           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   2623           * @param   disableDefaultRsp - decides default response is necessary or not
   2624           * @param   seqNum - sequence number of the command packet
   2625           *
   2626           * @return  ZStatus_t
   2627           */
   2628          ZStatus_t zclClosures_SendDoorLockScheduleRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   2629                                                             uint8 scheduleID, uint16 userID,
   2630                                                             uint8 disableDefaultRsp, uint8 seqNum )
   2631          {
   2632            uint8 payload[PAYLOAD_LEN_SCHEDULE];
   2633          
   2634            payload[0] = scheduleID;
   2635            payload[1] = LO_UINT16(userID);
   2636            payload[2] = HI_UINT16(userID);
   2637          
   2638            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2639                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2640                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_SCHEDULE, payload );
   2641          }
   2642          
   2643          /*********************************************************************
   2644           * @fn      zclClosures_SendDoorLockSetYearDayScheduleRequest
   2645           *
   2646           * @brief   Call to send out a Set Year Day Schedule Command
   2647           *
   2648           * @param   srcEP - Sending application's endpoint
   2649           * @param   dstAddr - where you want the message to go
   2650           * @param   scheduleID - The Schedule ID # is between 0 - [# Schedule IDs per user attribute]
   2651           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   2652           * @param   zigBeeLocalStartTime - Start time of the Year Day Schedule representing by ZigBeeLocalTime
   2653           * @param   zigBeeLocalEndTime - End time of the Year Day Schedule representing by ZigBeeLocalTime
   2654           * @param   disableDefaultRsp - decides default response is necessary or not
   2655           * @param   seqNum - sequence number of the command packet
   2656           *
   2657           * @return  ZStatus_t
   2658           */
   2659          ZStatus_t zclClosures_SendDoorLockSetYearDayScheduleRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2660                                                                       uint8 scheduleID, uint16 userID,
   2661                                                                       uint32 zigBeeLocalStartTime,
   2662                                                                       uint32 zigBeeLocalEndTime,
   2663                                                                       uint8 disableDefaultRsp, uint8 seqNum )
   2664          {
   2665            uint8 payload[PAYLOAD_LEN_SET_YEAR_DAY_SCHEDULE];
   2666          
   2667            payload[0] = scheduleID;
   2668            payload[1] = LO_UINT16(userID);
   2669            payload[2] = HI_UINT16(userID);
   2670            payload[3] = BREAK_UINT32(zigBeeLocalStartTime, 0);
   2671            payload[4] = BREAK_UINT32(zigBeeLocalStartTime, 1);
   2672            payload[5] = BREAK_UINT32(zigBeeLocalStartTime, 2);
   2673            payload[6] = BREAK_UINT32(zigBeeLocalStartTime, 3);
   2674            payload[7] = BREAK_UINT32(zigBeeLocalEndTime, 0);
   2675            payload[8] = BREAK_UINT32(zigBeeLocalEndTime, 1);
   2676            payload[9] = BREAK_UINT32(zigBeeLocalEndTime, 2);
   2677            payload[10] = BREAK_UINT32(zigBeeLocalEndTime, 3);
   2678          
   2679            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2680                                    COMMAND_CLOSURES_SET_YEAR_DAY_SCHEDULE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2681                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_SET_YEAR_DAY_SCHEDULE, payload );
   2682          }
   2683          
   2684          /*********************************************************************
   2685           * @fn      zclClosures_SendDoorLockSetHolidayScheduleRequest
   2686           *
   2687           * @brief   Call to send out a Set Holiday Schedule Command
   2688           *
   2689           * @param   srcEP - Sending application's endpoint
   2690           * @param   dstAddr - where you want the message to go
   2691           * @param   holidayScheduleID - A unique ID for given Holiday Schedule (0 to 254)
   2692           * @param   zigBeeLocalStartTime - Start time of the Year Day Schedule representing by ZigBeeLocalTime
   2693           * @param   zigBeeLocalEndTime - End time of the Year Day Schedule representing by ZigBeeLocalTime
   2694           * @param   operatingModeDuringHoliday - A valid enumeration value as listed in operating mode attribute
   2695           * @param   disableDefaultRsp - decides default response is necessary or not
   2696           * @param   seqNum - sequence number of the command packet
   2697           *
   2698           * @return  ZStatus_t
   2699           */
   2700          ZStatus_t zclClosures_SendDoorLockSetHolidayScheduleRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2701                                                                       uint8 holidayScheduleID,
   2702                                                                       uint32 zigBeeLocalStartTime,
   2703                                                                       uint32 zigBeeLocalEndTime,
   2704                                                                       uint8 operatingModeDuringHoliday,
   2705                                                                       uint8 disableDefaultRsp, uint8 seqNum )
   2706          {
   2707            uint8 payload[PAYLOAD_LEN_SET_HOLIDAY_SCHEDULE];
   2708          
   2709            payload[0] = holidayScheduleID;
   2710            payload[1] = BREAK_UINT32(zigBeeLocalStartTime, 0);
   2711            payload[2] = BREAK_UINT32(zigBeeLocalStartTime, 1);
   2712            payload[3] = BREAK_UINT32(zigBeeLocalStartTime, 2);
   2713            payload[4] = BREAK_UINT32(zigBeeLocalStartTime, 3);
   2714            payload[5] = BREAK_UINT32(zigBeeLocalEndTime, 0);
   2715            payload[6] = BREAK_UINT32(zigBeeLocalEndTime, 1);
   2716            payload[7] = BREAK_UINT32(zigBeeLocalEndTime, 2);
   2717            payload[8] = BREAK_UINT32(zigBeeLocalEndTime, 3);
   2718            payload[9] = operatingModeDuringHoliday;
   2719          
   2720            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2721                                    COMMAND_CLOSURES_SET_HOLIDAY_SCHEDULE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2722                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_SET_HOLIDAY_SCHEDULE, payload );
   2723          }
   2724          
   2725          /*********************************************************************
   2726           * @fn      zclClosures_SendDoorLockHolidayScheduleRequest
   2727           *
   2728           * @brief   Call to send out a Holiday Schedule Command
   2729           *
   2730           * @param   srcEP - Sending application's endpoint
   2731           * @param   dstAddr - where you want the message to go
   2732           * @param   cmd - COMMAND_CLOSURES_GET_HOLIDAY_SCHEDULE, COMMAND_CLOSURES_CLEAR_HOLIDAY_SCHEDULE
   2733           * @param   holidayScheduleID - A unique ID for given Holiday Schedule (0 to 254)
   2734           * @param   disableDefaultRsp - decides default response is necessary or not
   2735           * @param   seqNum - sequence number of the command packet
   2736           *
   2737           * @return  ZStatus_t
   2738           */
   2739          ZStatus_t zclClosures_SendDoorLockHolidayScheduleRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   2740                                                                    uint8 holidayScheduleID,
   2741                                                                    uint8 disableDefaultRsp, uint8 seqNum )
   2742          {
   2743            uint8 payload[PAYLOAD_LEN_HOLIDAY_SCHEDULE];
   2744          
   2745            payload[0] = holidayScheduleID;
   2746          
   2747            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2748                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2749                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_HOLIDAY_SCHEDULE, payload );
   2750          }
   2751          
   2752          /*********************************************************************
   2753           * @fn      zclClosures_SendDoorLockSetUserTypeRequest
   2754           *
   2755           * @brief   Call to send out a Set User Type Command
   2756           *
   2757           * @param   srcEP - Sending application's endpoint
   2758           * @param   dstAddr - where you want the message to go
   2759           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   2760           * @param   userType - Used to indicate what the type is for a specific User ID
   2761           * @param   disableDefaultRsp - decides default response is necessary or not
   2762           * @param   seqNum - sequence number of the command packet
   2763           *
   2764           * @return  ZStatus_t
   2765           */
   2766          ZStatus_t zclClosures_SendDoorLockSetUserTypeRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2767                                                                uint16 userID, uint8 userType,
   2768                                                                uint8 disableDefaultRsp, uint8 seqNum )
   2769          {
   2770            uint8 payload[PAYLOAD_LEN_SET_USER_TYPE];
   2771          
   2772            payload[0] = LO_UINT16(userID);
   2773            payload[1] = HI_UINT16(userID);
   2774            payload[2] = userType;
   2775          
   2776            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2777                                    COMMAND_CLOSURES_SET_USER_TYPE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2778                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_SET_USER_TYPE, payload );
   2779          }
   2780          
   2781          /*********************************************************************
   2782           * @fn      zclClosures_SendDoorLockSetRFIDCodeRequest
   2783           *
   2784           * @brief   Call to send out a Set RFID Code Command
   2785           *
   2786           * @param   srcEP - Sending application's endpoint
   2787           * @param   dstAddr - where you want the message to go
   2788           * @param   pPayload:
   2789           *           userID - User ID is between 0 - [# PINs User supported attribute]
   2790           *           userStatus - Used to indicate what the status is for a specific User ID
   2791           *           userType - Used to indicate what the type is for a specific User ID
   2792           *           aRfidCode - A ZigBee string indicating the RFID code used to create the event
   2793           * @param   disableDefaultRsp - decides default response is necessary or not
   2794           * @param   seqNum - sequence number of the command packet
   2795           *
   2796           * @return  ZStatus_t
   2797           */
   2798          ZStatus_t zclClosures_SendDoorLockSetRFIDCodeRequest( uint8 srcEP, afAddrType_t *dstAddr,
   2799                                                                zclDoorLockSetRFIDCode_t *pPayload,
   2800                                                                uint8 disableDefaultRsp, uint8 seqNum )
   2801          {
   2802            uint8 i;
   2803            uint8 *pBuf;  // variable length payload
   2804            uint8 offset;
   2805            uint8 calculatedArrayLen;
   2806            uint8 calculatedBufSize;
   2807            ZStatus_t status;
   2808          
   2809            // first octet of PIN/RFID Code variable string identifies its length
   2810            calculatedArrayLen = pPayload->pRfidCode[0] + 1;   // add first byte of string
   2811          
   2812            // determine the total buffer size
   2813            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_SET_RFID_CODE;
   2814          
   2815            pBuf = zcl_mem_alloc( calculatedBufSize );
   2816            if ( !pBuf )
   2817            {
   2818              return ( ZMemError );  // no memory
   2819            }
   2820          
   2821            // over-the-air is always little endian. Break into a byte stream.
   2822            pBuf[0] = LO_UINT16(pPayload->userID);
   2823            pBuf[1] = HI_UINT16(pPayload->userID);
   2824            pBuf[2] = pPayload->userStatus;
   2825            pBuf[3] = pPayload->userType;
   2826            offset = 4;
   2827            for ( i = 0; i < calculatedArrayLen; i++ )
   2828            {
   2829              pBuf[offset++] = pPayload->pRfidCode[i];
   2830            }
   2831          
   2832            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2833                                      COMMAND_CLOSURES_SET_RFID_CODE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   2834                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   2835            zcl_mem_free( pBuf );
   2836            return status;
   2837          }
   2838          
   2839          /*********************************************************************
   2840           * @fn      zclClosures_SendDoorLockStatusResponse
   2841           *
   2842           * @brief   Call to send out a Status Response
   2843           *
   2844           * @param   srcEP - Sending application's endpoint
   2845           * @param   dstAddr - where you want the message to go
   2846           * @param   cmd - COMMAND_CLOSURES_LOCK_DOOR_RSP, COMMAND_CLOSURES_UNLOCK_DOOR_RSP
   2847           *                COMMAND_CLOSURES_TOGGLE_RSP, COMMAND_CLOSURES_UNLOCK_WITH_TIMEOUT_RSP,
   2848           *                COMMAND_CLOSURES_SET_PIN_CODE_RSP, COMMAND_CLOSURES_CLEAR_PIN_CODE_RSP,
   2849           *                COMMAND_CLOSURES_CLEAR_ALL_PIN_CODES_RSP, COMMAND_CLOSURES_SET_USER_STATUS_RSP,
   2850           *                COMMAND_CLOSURES_SET_WEEK_DAY_SCHEDULE_RSP, COMMAND_CLOSURES_CLEAR_WEEK_DAY_SCHEDULE_RSP,
   2851           *                COMMAND_CLOSURES_SET_YEAR_DAY_SCHEDULE_RSP, COMMAND_CLOSURES_CLEAR_YEAR_DAY_SCHEDULE_RSP,
   2852           *                COMMAND_CLOSURES_SET_HOLIDAY_SCHEDULE_RSP, COMMAND_CLOSURES_CLEAR_HOLIDAY_SCHEDULE_RSP,
   2853           *                COMMAND_CLOSURES_SET_USER_TYPE_RSP, COMMAND_CLOSURES_SET_RFID_CODE_RSP,
   2854           *                COMMAND_CLOSURES_CLEAR_RFID_CODE_RSP, COMMAND_CLOSURES_CLEAR_ALL_RFID_CODES_RSP
   2855           * @param   status - Returns the state due to the requesting command
   2856           * @param   disableDefaultRsp - decides default response is necessary or not
   2857           * @param   seqNum - sequence number of the command packet
   2858           *
   2859           * @return  ZStatus_t
   2860           */
   2861          ZStatus_t zclClosures_SendDoorLockStatusResponse( uint8 srcEP, afAddrType_t *dstAddr,uint8 cmd,
   2862                                                            uint8 status, uint8 disableDefaultRsp, uint8 seqNum )
   2863          {
   2864            uint8 payload[1];   // 1 byte payload
   2865          
   2866            payload[0] = status;
   2867          
   2868            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2869                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   2870                                    disableDefaultRsp, 0, seqNum, sizeof( payload ), payload );
   2871          }
   2872          
   2873          /*********************************************************************
   2874           * @fn      zclClosures_SendDoorLockGetLogRecordResponse
   2875           *
   2876           * @brief   Call to send out a Get Log Record Response
   2877           *
   2878           * @param   srcEP - Sending application's endpoint
   2879           * @param   dstAddr - where you want the message to go
   2880           * @param   pPayload:
   2881           *           logEntryID - The index into the log table where this log entry is stored
   2882           *           timestamp - A ZigBeeLocalTime used to timestamp all events and alarms on the door lock
   2883           *           eventType - Indicates the type of event that took place on the door lock
   2884           *           source - A source value of available sources
   2885           *           eventIDAlarmCode - A one byte value indicating the type of event that took place on the door lock
   2886           *           userID - User ID is between 0 - [# PINs User supported attribute]
   2887           *           aPIN - A ZigBee string indicating the PIN code used to create the event on the door lock
   2888           * @param   disableDefaultRsp - decides default response is necessary or not
   2889           * @param   seqNum - sequence number of the command packet
   2890           *
   2891           * @return  ZStatus_t
   2892           */
   2893          ZStatus_t zclClosures_SendDoorLockGetLogRecordResponse( uint8 srcEP, afAddrType_t *dstAddr,
   2894                                                                  zclDoorLockGetLogRecordRsp_t *pPayload,
   2895                                                                  uint8 disableDefaultRsp, uint8 seqNum )
   2896          {
   2897            uint8 i;
   2898            uint8 *pBuf;  // variable length payload
   2899            uint8 offset;
   2900            uint8 calculatedArrayLen;
   2901            uint8 calculatedBufSize;
   2902            ZStatus_t status;
   2903          
   2904            // first octet of PIN/RFID Code variable string identifies its length
   2905            calculatedArrayLen = pPayload->pPIN[0] + 1;   // add first byte of string
   2906          
   2907            // determine the total buffer size
   2908            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_GET_LOG_RECORD_RSP;
   2909          
   2910            pBuf = zcl_mem_alloc( calculatedBufSize );
   2911            if ( !pBuf )
   2912            {
   2913              return ( ZMemError );  // no memory
   2914            }
   2915          
   2916            // over-the-air is always little endian. Break into a byte stream.
   2917            pBuf[0] = LO_UINT16(pPayload->logEntryID);
   2918            pBuf[1] = HI_UINT16(pPayload->logEntryID);
   2919            pBuf[2] = BREAK_UINT32(pPayload->timestamp, 0);
   2920            pBuf[3] = BREAK_UINT32(pPayload->timestamp, 1);
   2921            pBuf[4] = BREAK_UINT32(pPayload->timestamp, 2);
   2922            pBuf[5] = BREAK_UINT32(pPayload->timestamp, 3);
   2923            pBuf[6] = pPayload->eventType;
   2924            pBuf[7] = pPayload->source;
   2925            pBuf[8] = pPayload->eventIDAlarmCode;
   2926            pBuf[9] = LO_UINT16(pPayload->userID);
   2927            pBuf[10] = HI_UINT16(pPayload->userID);
   2928            offset = 11;
   2929            for ( i = 0; i < calculatedArrayLen; i++ )
   2930            {
   2931              pBuf[offset++] = pPayload->pPIN[i];
   2932            }
   2933          
   2934            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2935                                      COMMAND_CLOSURES_GET_LOG_RECORD_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   2936                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   2937            zcl_mem_free( pBuf );
   2938            return status;
   2939          }
   2940          
   2941          /*********************************************************************
   2942           * @fn      zclClosures_SendDoorLockGetPINCodeResponse
   2943           *
   2944           * @brief   Call to send out a Get PIN Code Response
   2945           *
   2946           * @param   srcEP - Sending application's endpoint
   2947           * @param   dstAddr - where you want the message to go
   2948           * @param   pPayload:
   2949           *           userID - User ID is between 0 - [# PINs User supported attribute]
   2950           *           userStatus - Used to indicate what the status is for a specific User ID
   2951           *           userType - Used to indicate what the type is for a specific User ID
   2952           *           aCode - Returned PIN number
   2953           * @param   disableDefaultRsp - decides default response is necessary or not
   2954           * @param   seqNum - sequence number of the command packet
   2955           *
   2956           * @return  ZStatus_t
   2957           */
   2958          ZStatus_t zclClosures_SendDoorLockGetPINCodeResponse( uint8 srcEP, afAddrType_t *dstAddr,
   2959                                                                zclDoorLockGetPINCodeRsp_t *pPayload,
   2960                                                                uint8 disableDefaultRsp, uint8 seqNum )
   2961          {
   2962            uint8 i;
   2963            uint8 *pBuf;  // variable length payload
   2964            uint8 offset;
   2965            uint8 calculatedArrayLen;
   2966            uint8 calculatedBufSize;
   2967            ZStatus_t status;
   2968          
   2969            // first octet of PIN/RFID Code variable string identifies its length
   2970            calculatedArrayLen = pPayload->pCode[0] + 1;   // add first byte of string
   2971          
   2972            // determine the total buffer size
   2973            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_GET_PIN_CODE_RSP;
   2974          
   2975            pBuf = zcl_mem_alloc( calculatedBufSize );
   2976            if ( !pBuf )
   2977            {
   2978              return ( ZMemError );  // no memory
   2979            }
   2980          
   2981            // over-the-air is always little endian. Break into a byte stream.
   2982            pBuf[0] = LO_UINT16(pPayload->userID);
   2983            pBuf[1] = HI_UINT16(pPayload->userID);
   2984            pBuf[2] = pPayload->userStatus;
   2985            pBuf[3] = pPayload->userType;
   2986            offset = 4;
   2987            for ( i = 0; i < calculatedArrayLen; i++ )
   2988            {
   2989              pBuf[offset++] = pPayload->pCode[i];
   2990            }
   2991          
   2992            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   2993                                      COMMAND_CLOSURES_GET_PIN_CODE_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   2994                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   2995            zcl_mem_free( pBuf );
   2996            return status;
   2997          }
   2998          
   2999          /*********************************************************************
   3000           * @fn      zclClosures_SendDoorLockGetUserStatusResponse
   3001           *
   3002           * @brief   Call to send out a Get User Status Response
   3003           *
   3004           * @param   srcEP - Sending application's endpoint
   3005           * @param   dstAddr - where you want the message to go
   3006           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   3007           * @param   userStatus - Used to indicate what the status is for a specific User ID
   3008           * @param   disableDefaultRsp - decides default response is necessary or not
   3009           * @param   seqNum - sequence number of the command packet
   3010           *
   3011           * @return  ZStatus_t
   3012           */
   3013          ZStatus_t zclClosures_SendDoorLockGetUserStatusResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3014                                                                   uint16 userID, uint8 userStatus,
   3015                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   3016          {
   3017            uint8 payload[PAYLOAD_LEN_GET_USER_STATUS_RSP];
   3018          
   3019            payload[0] = LO_UINT16(userID);
   3020            payload[1] = HI_UINT16(userID);
   3021            payload[2] = userStatus;
   3022          
   3023            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3024                                    COMMAND_CLOSURES_GET_USER_STATUS_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3025                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_GET_USER_STATUS_RSP, payload );
   3026          }
   3027          
   3028          /*********************************************************************
   3029           * @fn      zclClosures_SendDoorLockGetWeekDayScheduleResponse
   3030           *
   3031           * @brief   Call to send out a Get Week Day Schedule Response
   3032           *
   3033           * @param   srcEP - Sending application's endpoint
   3034           * @param   dstAddr - where you want the message to go
   3035           * @param   pCmd:
   3036           *               scheduleID - The Schedule ID # is between 0 - [# Schedule IDs per user attribute]
   3037           *               userID - User ID is between 0 - [# PINs User supported attribute]
   3038           *               status - Returns the state due to the requesting command
   3039           *               daysMask - Bitmask of the effective days in the order XSFTWTMS
   3040           *               startHour - The start hour of the Week Day Schedule: 0-23
   3041           *               startMinute - The start minute of the Week Day Schedule: 0-59
   3042           *               endHour - The end hour of the Week Day Schedule: 0-23
   3043           *               endMinute - The end minute of the Week Day Schedule: 0-59
   3044           * @param   disableDefaultRsp - decides default response is necessary or not
   3045           * @param   seqNum - sequence number of the command packet
   3046           *
   3047           * @return  ZStatus_t
   3048           */
   3049          ZStatus_t zclClosures_SendDoorLockGetWeekDayScheduleResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3050                                                                        zclDoorLockGetWeekDayScheduleRsp_t *pCmd,
   3051                                                                        uint8 disableDefaultRsp, uint8 seqNum )
   3052          {
   3053            uint8 payload[PAYLOAD_LEN_GET_WEEK_DAY_SCHEDULE_RSP];
   3054            uint8 payloadLen = sizeof( payload );
   3055          
   3056            payload[0] = pCmd->scheduleID;
   3057            payload[1] = LO_UINT16( pCmd->userID );
   3058            payload[2] = HI_UINT16( pCmd->userID );
   3059            payload[3] = pCmd->status;
   3060          
   3061            if ( pCmd->status == ZCL_STATUS_SUCCESS )
   3062            {
   3063              payload[4] = pCmd->daysMask;
   3064              payload[5] = pCmd->startHour;
   3065              payload[6] = pCmd->startMinute;
   3066              payload[7] = pCmd->endHour;
   3067              payload[8] = pCmd->endMinute;
   3068            }
   3069            else
   3070            {
   3071              payloadLen = 4;
   3072            }
   3073          
   3074            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3075                                    COMMAND_CLOSURES_GET_WEEK_DAY_SCHEDULE_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3076                                    disableDefaultRsp, 0, seqNum, payloadLen, payload );
   3077          }
   3078          
   3079          /*********************************************************************
   3080           * @fn      zclClosures_SendDoorLockGetYearDayScheduleResponse
   3081           *
   3082           * @brief   Call to send out a Get Year Day Schedule Response
   3083           *
   3084           * @param   srcEP - Sending application's endpoint
   3085           * @param   dstAddr - where you want the message to go
   3086           * @param   pCmd:
   3087           *             scheduleID - The Schedule ID # is between 0 - [# Schedule IDs per user attribute]
   3088           *             userID - User ID is between 0 - [# PINs User supported attribute]
   3089           *             status - Returns the state due to the requesting command
   3090           *             zigBeeLocalStartTime - Start time of the Year Day Schedule representing by ZigBeeLocalTime
   3091           *             zigBeeLocalEndTime - End time of the Year Day Schedule representing by ZigBeeLocalTime
   3092           * @param   disableDefaultRsp - decides default response is necessary or not
   3093           * @param   seqNum - sequence number of the command packet
   3094           *
   3095           * @return  ZStatus_t
   3096           */
   3097          ZStatus_t zclClosures_SendDoorLockGetYearDayScheduleResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3098                                                                        zclDoorLockGetYearDayScheduleRsp_t *pCmd,
   3099                                                                        uint8 disableDefaultRsp, uint8 seqNum )
   3100          {
   3101            uint8 payload[PAYLOAD_LEN_GET_YEAR_DAY_SCHEDULE_RSP];
   3102            uint8 payloadLen = sizeof( payload );
   3103          
   3104            payload[0] = pCmd->scheduleID;
   3105            payload[1] = LO_UINT16( pCmd->userID );
   3106            payload[2] = HI_UINT16( pCmd->userID );
   3107            payload[3] = pCmd->status;
   3108          
   3109            if ( pCmd->status == ZCL_STATUS_SUCCESS )
   3110            {
   3111              payload[4] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 0 );
   3112              payload[5] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 1 );
   3113              payload[6] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 2 );
   3114              payload[7] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 3 );
   3115              payload[8] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 0 );
   3116              payload[9] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 1 );
   3117              payload[10] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 2 );
   3118              payload[11] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 3 );
   3119            }
   3120            else
   3121            {
   3122              payloadLen = 4;
   3123            }
   3124          
   3125            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3126                                    COMMAND_CLOSURES_GET_YEAR_DAY_SCHEDULE_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3127                                    disableDefaultRsp, 0, seqNum, payloadLen, payload );
   3128          }
   3129          
   3130          /*********************************************************************
   3131           * @fn      zclClosures_SendDoorLockGetHolidayScheduleResponse
   3132           *
   3133           * @brief   Call to send out a Get Holiday Schedule Response
   3134           *
   3135           * @param   srcEP - Sending application's endpoint
   3136           * @param   dstAddr - where you want the message to go
   3137           * @param   pCmd:
   3138           *             holidayScheduleID - A unique ID for given Holiday Schedule (0 to 254)
   3139           *             status - Returns the state due to the requesting command
   3140           *             zigBeeLocalStartTime - Start time of the Year Day Schedule representing by ZigBeeLocalTime
   3141           *             zigBeeLocalEndTime - End time of the Year Day Schedule representing by ZigBeeLocalTime
   3142           *             operatingModeDuringHoliday - A valid enumeration value as listed in operating mode attribute
   3143           * @param   disableDefaultRsp - decides default response is necessary or not
   3144           * @param   seqNum - sequence number of the command packet
   3145           *
   3146           * @return  ZStatus_t
   3147           */
   3148          ZStatus_t zclClosures_SendDoorLockGetHolidayScheduleResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3149                                                                        zclDoorLockGetHolidayScheduleRsp_t *pCmd,
   3150                                                                        uint8 disableDefaultRsp, uint8 seqNum )
   3151          {
   3152            uint8 payload[PAYLOAD_LEN_GET_HOLIDAY_SCHEDULE_RSP];
   3153            uint8 payloadLen = sizeof( payload );
   3154          
   3155            payload[0] = pCmd->holidayScheduleID;
   3156            payload[1] = pCmd->status;
   3157          
   3158            if ( pCmd->status == ZCL_STATUS_SUCCESS )
   3159            {
   3160              payload[2] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 0 );
   3161              payload[3] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 1 );
   3162              payload[4] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 2 );
   3163              payload[5] = BREAK_UINT32( pCmd->zigBeeLocalStartTime, 3 );
   3164              payload[6] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 0 );
   3165              payload[7] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 1 );
   3166              payload[8] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 2 );
   3167              payload[9] = BREAK_UINT32( pCmd->zigBeeLocalEndTime, 3 );
   3168              payload[10] = pCmd->operatingModeDuringHoliday;
   3169            }
   3170            else
   3171            {
   3172              payloadLen = 2;
   3173            }
   3174          
   3175            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3176                                    COMMAND_CLOSURES_GET_HOLIDAY_SCHEDULE_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3177                                    disableDefaultRsp, 0, seqNum, payloadLen, payload );
   3178          }
   3179          
   3180          /*********************************************************************
   3181           * @fn      zclClosures_SendDoorLockGetUserTypeResponse
   3182           *
   3183           * @brief   Call to send out a Get User Type Response
   3184           *
   3185           * @param   srcEP - Sending application's endpoint
   3186           * @param   dstAddr - where you want the message to go
   3187           * @param   userID - User ID is between 0 - [# PINs User supported attribute]
   3188           * @param   userType - Used to indicate what the type is for a specific User ID
   3189           * @param   disableDefaultRsp - decides default response is necessary or not
   3190           * @param   seqNum - sequence number of the command packet
   3191           *
   3192           * @return  ZStatus_t
   3193           */
   3194          ZStatus_t zclClosures_SendDoorLockGetUserTypeResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3195                                                                 uint16 userID, uint8 userType,
   3196                                                                 uint8 disableDefaultRsp, uint8 seqNum )
   3197          {
   3198            uint8 payload[PAYLOAD_LEN_GET_USER_TYPE_RSP];
   3199          
   3200            payload[0] = LO_UINT16(userID);
   3201            payload[1] = HI_UINT16(userID);
   3202            payload[2] = userType;
   3203          
   3204            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3205                                    COMMAND_CLOSURES_GET_USER_TYPE_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3206                                    disableDefaultRsp, 0, seqNum, PAYLOAD_LEN_GET_USER_TYPE_RSP, payload );
   3207          }
   3208          
   3209          /*********************************************************************
   3210           * @fn      zclClosures_SendDoorLockGetRFIDCodeResponse
   3211           *
   3212           * @brief   Call to send out a Get RFID Code Response
   3213           *
   3214           * @param   srcEP - Sending application's endpoint
   3215           * @param   dstAddr - where you want the message to go
   3216           * @param   pPayload:
   3217           *           userID - User ID is between 0 - [# PINs User supported attribute]
   3218           *           userStatus - Used to indicate what the status is for a specific User ID
   3219           *           userType - Used to indicate what the type is for a specific User ID
   3220           *           aRfidCode - A ZigBee string indicating the RFID code used to create the event
   3221           * @param   disableDefaultRsp - decides default response is necessary or not
   3222           * @param   seqNum - sequence number of the command packet
   3223           *
   3224           * @return  ZStatus_t
   3225           */
   3226          ZStatus_t zclClosures_SendDoorLockGetRFIDCodeResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3227                                                                 zclDoorLockGetRFIDCodeRsp_t *pPayload,
   3228                                                                 uint8 disableDefaultRsp, uint8 seqNum )
   3229          {
   3230            uint8 i;
   3231            uint8 *pBuf;  // variable length payload
   3232            uint8 offset;
   3233            uint8 calculatedArrayLen;
   3234            uint8 calculatedBufSize;
   3235            ZStatus_t status;
   3236          
   3237            // first octet of PIN/RFID Code variable string identifies its length
   3238            calculatedArrayLen = pPayload->pRfidCode[0] + 1;   // add first byte of string
   3239          
   3240            // determine total size of buffer
   3241            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_GET_RFID_CODE_RSP;
   3242          
   3243            pBuf = zcl_mem_alloc( calculatedBufSize );
   3244            if ( !pBuf )
   3245            {
   3246              return ( ZMemError );  // no memory
   3247            }
   3248          
   3249            // over-the-air is always little endian. Break into a byte stream.
   3250            pBuf[0] = LO_UINT16(pPayload->userID);
   3251            pBuf[1] = HI_UINT16(pPayload->userID);
   3252            pBuf[2] = pPayload->userStatus;
   3253            pBuf[3] = pPayload->userType;
   3254            offset = 4;
   3255            for ( i = 0; i < calculatedArrayLen; i++ )
   3256            {
   3257              pBuf[offset++] = pPayload->pRfidCode[i];
   3258            }
   3259          
   3260            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3261                                      COMMAND_CLOSURES_GET_RFID_CODE_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3262                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   3263            zcl_mem_free( pBuf );
   3264            return status;
   3265          }
   3266          
   3267          ZStatus_t zclClosures_SendSetTemporaryPinStatusResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3268                                                            uint8 status, uint8 disableDefaultRsp, uint8 seqNum )
   3269          {
   3270            uint8 payload[1];   // 1 byte payload
   3271          
   3272            payload[0] = status;
   3273          
   3274            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3275                                    COMMAND_CLOSURES_SET_TEMPORARY_PIN_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3276                                    disableDefaultRsp, 0, seqNum, sizeof( payload ), payload );
   3277          }
   3278          
   3279          ZStatus_t zclClosures_SendModifyPinStatusResponse( uint8 srcEP, afAddrType_t *dstAddr,
   3280                                                            uint8 status, uint8 disableDefaultRsp, uint8 seqNum )
   3281          {
   3282            uint8 payload[1];   // 1 byte payload
   3283          
   3284            payload[0] = status;
   3285          
   3286            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3287                                    COMMAND_CLOSURES_MODIFY_PIN_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3288                                    disableDefaultRsp, 0, seqNum, sizeof( payload ), payload );
   3289          }
   3290          
   3291          /*********************************************************************
   3292           * @fn      zclClosures_SendDoorLockOperationEventNotification
   3293           *
   3294           * @brief   Call to send out a Operation Event Notification
   3295           *
   3296           * @param   srcEP - Sending application's endpoint
   3297           * @param   dstAddr - where you want the message to go
   3298           * @param   pPayload:
   3299           *           operationEventSource - Indicates where the event was triggered from
   3300           *           operationEventCode - (Optional) a notification whenever there is a significant operation event on the lock
   3301           *           userID - User ID is between 0 - [# PINs User supported attribute]
   3302           *           pin - The PIN that is associated with the User ID who performed the event
   3303           *           zigBeeLocalTime - Indicates when the event is triggered
   3304           *           aData - Used to pass data associated with a particular event
   3305           * @param   disableDefaultRsp - decides default response is necessary or not
   3306           * @param   seqNum - sequence number of the command packet
   3307           *
   3308           * @return  ZStatus_t
   3309           */
   3310          ZStatus_t zclClosures_SendDoorLockOperationEventNotification( uint8 srcEP, afAddrType_t *dstAddr,
   3311                                                                        zclDoorLockOperationEventNotification_t *pPayload,
   3312                                                                        uint8 disableDefaultRsp, uint8 seqNum )
   3313          {
   3314            uint8 i;
   3315            uint8 *pBuf;  // variable length payload
   3316            uint8 offset;
   3317            uint8 calculatedArrayLen;
   3318            uint16 calculatedBufSize;
   3319            ZStatus_t status;
   3320          
   3321            // set variable length if data is available
   3322            calculatedArrayLen = pPayload->pData[0] + 1; // add first byte of string
   3323          
   3324            // determine total size of buffer
   3325            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_OPERATION_EVENT_NOTIFICATION;
   3326          
   3327            pBuf = zcl_mem_alloc( calculatedBufSize );
   3328            if ( !pBuf )
   3329            {
   3330              return ( ZMemError );  // no memory
   3331            }
   3332          
   3333            // over-the-air is always little endian. Break into a byte stream.
   3334            pBuf[0] = pPayload->operationEventSource;
   3335            pBuf[1] = pPayload->operationEventCode;
   3336            pBuf[2] = LO_UINT16( pPayload->userID );
   3337            pBuf[3] = HI_UINT16( pPayload->userID );
   3338            pBuf[4] = pPayload->pin;
   3339            pBuf[5] = BREAK_UINT32(pPayload->zigBeeLocalTime, 0);
   3340            pBuf[6] = BREAK_UINT32(pPayload->zigBeeLocalTime, 1);
   3341            pBuf[7] = BREAK_UINT32(pPayload->zigBeeLocalTime, 2);
   3342            pBuf[8] = BREAK_UINT32(pPayload->zigBeeLocalTime, 3);
   3343            offset = 9;
   3344            for ( i = 0; i < calculatedArrayLen; i++ )
   3345            {
   3346              pBuf[offset++] = pPayload->pData[i];
   3347            }
   3348          
   3349            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3350                                      COMMAND_CLOSURES_OPERATION_EVENT_NOTIFICATION, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3351                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   3352            zcl_mem_free( pBuf );
   3353            return status;
   3354          }
   3355          
   3356          /*********************************************************************
   3357           * @fn      zclClosures_SendDoorLockProgrammingEventNotification
   3358           *
   3359           * @brief   Call to send out a Programming Event Notification
   3360           *
   3361           * @param   srcEP - Sending application's endpoint
   3362           * @param   dstAddr - where you want the message to go
   3363           * @param   pPayload:
   3364           *           programEventSource - Indicates where the event was triggered from
   3365           *           programEventCode - (Optional) a notification whenever there is a significant programming event on the lock
   3366           *           userID - User ID is between 0 - [# PINs User supported attribute]
   3367           *           pin - The PIN that is associated with the User ID who performed the event
   3368           *           userType - Used to indicate what the type is for a specific User ID
   3369           *           userStatus - Used to indicate what the status is for a specific User ID
   3370           *           zigBeeLocalTime - Indicates when the event is triggered
   3371           *           dataLen - Manufacture specific, describes length of aData
   3372           *           aData - Used to pass data associated with a particular event
   3373           * @param   disableDefaultRsp - decides default response is necessary or not
   3374           * @param   seqNum - sequence number of the command packet
   3375           *
   3376           * @return  ZStatus_t
   3377           */
   3378          ZStatus_t zclClosures_SendDoorLockProgrammingEventNotification( uint8 srcEP, afAddrType_t *dstAddr,
   3379                                                                          zclDoorLockProgrammingEventNotification_t *pPayload,
   3380                                                                          uint8 disableDefaultRsp, uint8 seqNum )
   3381          {
   3382            uint8 i;
   3383            uint8 *pBuf;  // variable length payload
   3384            uint8 offset;
   3385            uint8 calculatedArrayLen;
   3386            uint16 calculatedBufSize;
   3387            ZStatus_t status;
   3388          
   3389            // set variable length if data is available
   3390            calculatedArrayLen = pPayload->pData[0] + 1;  // add first byte of string
   3391          
   3392            // determine total size of buffer
   3393            calculatedBufSize = calculatedArrayLen + PAYLOAD_LEN_PROGRAMMING_EVENT_NOTIFICATION;
   3394          
   3395            pBuf = zcl_mem_alloc( calculatedBufSize );
   3396            if ( !pBuf )
   3397            {
   3398              return ( ZMemError );  // no memory
   3399            }
   3400          
   3401            // over-the-air is always little endian. Break into a byte stream.
   3402            pBuf[0] = pPayload->programEventSource;
   3403            pBuf[1] = pPayload->programEventCode;
   3404            pBuf[2] = LO_UINT16( pPayload->userID );
   3405            pBuf[3] = HI_UINT16( pPayload->userID );
   3406            pBuf[4] = pPayload->pin;
   3407            pBuf[5] = pPayload->userType;
   3408            pBuf[6] = pPayload->userStatus;
   3409            pBuf[7] = BREAK_UINT32(pPayload->zigBeeLocalTime, 0);
   3410            pBuf[8] = BREAK_UINT32(pPayload->zigBeeLocalTime, 1);
   3411            pBuf[9] = BREAK_UINT32(pPayload->zigBeeLocalTime, 2);
   3412            pBuf[10] = BREAK_UINT32(pPayload->zigBeeLocalTime, 3);
   3413            offset = 11;
   3414            for ( i = 0; i < calculatedArrayLen; i++ )
   3415            {
   3416              pBuf[offset++] = pPayload->pData[i];
   3417            }
   3418          
   3419            status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   3420                                      COMMAND_CLOSURES_PROGRAMMING_EVENT_NOTIFICATION, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   3421                                      disableDefaultRsp, 0, seqNum, calculatedBufSize, pBuf );
   3422            zcl_mem_free( pBuf );
   3423            return status;
   3424          }
   3425          
   3426          #endif //ZCL_DOORLOCK
   3427          
   3428          #ifdef ZCL_WINDOWCOVERING
   3429          /*********************************************************************
   3430           * @fn      zclClosures_ProcessInWindowCovering
   3431           *
   3432           * @brief   Process in the received Window Covering cluster Command.
   3433           *
   3434           * @param   pInMsg - pointer to the incoming message
   3435           *
   3436           * @return  ZStatus_t
   3437           */
   3438          static ZStatus_t zclClosures_ProcessInWindowCovering( zclIncoming_t *pInMsg,
   3439                                                                zclClosures_WindowCoveringAppCallbacks_t *pCBs )
   3440          {
   3441            ZStatus_t status = ZCL_STATUS_SUCCESS;
   3442            uint8 *pData = pInMsg->pData;
   3443          
   3444            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3445            {
   3446              switch ( pInMsg->hdr.commandID )
   3447              {
   3448              case COMMAND_CLOSURES_UP_OPEN:
   3449                if ( pCBs->pfnWindowCoveringUpOpen )
   3450                {
   3451                  pCBs->pfnWindowCoveringUpOpen();
   3452                }
   3453                break;
   3454          
   3455              case COMMAND_CLOSURES_DOWN_CLOSE:
   3456                if ( pCBs->pfnWindowCoveringDownClose )
   3457                {
   3458                  pCBs->pfnWindowCoveringDownClose();
   3459                }
   3460                break;
   3461          
   3462              case COMMAND_CLOSURES_STOP:
   3463                if ( pCBs->pfnWindowCoveringStop )
   3464                {
   3465                  pCBs->pfnWindowCoveringStop();
   3466                }
   3467                break;
   3468          
   3469              case COMMAND_CLOSURES_GO_TO_LIFT_VALUE:
   3470                if ( pCBs->pfnWindowCoveringGotoLiftValue )
   3471                {
   3472                  if ( pCBs->pfnWindowCoveringGotoLiftValue( BUILD_UINT16( pData[0], pData[1] ) ) == FALSE )
   3473                  {
   3474                    status = ZCL_STATUS_INVALID_VALUE;
   3475                  }
   3476                }
   3477                break;
   3478          
   3479              case COMMAND_CLOSURES_GO_TO_LIFT_PERCENTAGE:
   3480                if ( pCBs->pfnWindowCoveringGotoLiftPercentage )
   3481                {
   3482                  if ( pCBs->pfnWindowCoveringGotoLiftPercentage( pData[0] ) == FALSE )
   3483                  {
   3484                    status = ZCL_STATUS_INVALID_VALUE;
   3485                  }
   3486                }
   3487                break;
   3488          
   3489              case COMMAND_CLOSURES_GO_TO_TILT_VALUE:
   3490                if ( pCBs->pfnWindowCoveringGotoTiltValue )
   3491                {
   3492                  if ( pCBs->pfnWindowCoveringGotoTiltValue( BUILD_UINT16( pData[0], pData[1] ) ) == FALSE )
   3493                  {
   3494                    status = ZCL_STATUS_INVALID_VALUE;
   3495                  }
   3496                }
   3497                break;
   3498          
   3499              case COMMAND_CLOSURES_GO_TO_TILT_PERCENTAGE:
   3500                if ( pCBs->pfnWindowCoveringGotoTiltPercentage )
   3501                {
   3502                  if ( pCBs->pfnWindowCoveringGotoTiltPercentage( pData[0] ) == FALSE )
   3503                  {
   3504                    status = ZCL_STATUS_INVALID_VALUE;
   3505                  }
   3506                }
   3507                break;
   3508          
   3509              default:
   3510                return( ZFailure );
   3511              }
   3512            }
   3513            // no Client command
   3514          
   3515            return ( status );
   3516          }
   3517          
   3518          /*********************************************************************
   3519           * @fn      zclClosures_WindowCoveringSimpleReq
   3520           *
   3521           * @brief   Call to send out a Window Covering command with no payload
   3522           *          as Up/Open, Down/Close or Stop
   3523           *
   3524           * @param   srcEP - Sending application's endpoint
   3525           * @param   dstAddr - where you want the message to go
   3526           * @param   cmd - Command ID
   3527           * @param   disableDefaultRsp - decides default response is necessary or not
   3528           * @param   seqNum - sequence number of the command packet
   3529           *
   3530           * @return  ZStatus_t
   3531           */
   3532          ZStatus_t zclClosures_WindowCoveringSimpleReq( uint8 srcEP, afAddrType_t *dstAddr,
   3533                                                         uint8 cmd, uint8 disableDefaultRsp, uint8 seqNum )
   3534          {
   3535            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING,
   3536                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   3537                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   3538          }
   3539          
   3540          /*********************************************************************
   3541           * @fn      zclClosures_WindowCoveringSendGoToValueReq
   3542           *
   3543           * @brief   Call to send out a Go to Value Request Command
   3544           *
   3545           * @param   srcEP - Sending application's endpoint
   3546           * @param   dstAddr - where you want the message to go
   3547           * @param   cmd - Command ID for COMMAND_CLOSURES_GO_TO_LIFT_VALUE
   3548           * @param   liftValue - payload
   3549           * @param   disableDefaultRsp - decides default response is necessary or not
   3550           * @param   seqNum - sequence number of the command packet
   3551           *
   3552           * @return  ZStatus_t
   3553           */
   3554          ZStatus_t zclClosures_WindowCoveringSendGoToValueReq( uint8 srcEP, afAddrType_t *dstAddr,
   3555                                                                uint8 cmd, uint16 Value,
   3556                                                                uint8 disableDefaultRsp, uint8 seqNum )
   3557          {
   3558            uint8 buf[ZCL_WC_GOTOVALUEREQ_PAYLOADLEN];
   3559          
   3560            buf[0] = LO_UINT16( Value );
   3561            buf[1] = HI_UINT16( Value );
   3562          
   3563            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING,
   3564                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   3565                                    disableDefaultRsp, 0, seqNum,
   3566                                    ZCL_WC_GOTOVALUEREQ_PAYLOADLEN, buf );
   3567          }
   3568          
   3569          /*********************************************************************
   3570           * @fn      zclClosures_WindowCoveringSendGoToPercentageReq
   3571           *
   3572           * @brief   Call to send out a Go to Percentage Request Command
   3573           *
   3574           * @param   srcEP - Sending application's endpoint
   3575           * @param   dstAddr - where you want the message to go
   3576           * @param   cmd - Command ID e.g. COMMAND_CLOSURES_GO_TO_LIFT_PERCENTAGE
   3577           * @param   percentageLiftValue - payload
   3578           * @param   disableDefaultRsp - decides default response is necessary or not
   3579           * @param   seqNum - sequence number of the command packet
   3580           *
   3581           * @return  ZStatus_t
   3582           */
   3583          ZStatus_t zclClosures_WindowCoveringSendGoToPercentageReq( uint8 srcEP, afAddrType_t *dstAddr,
   3584                                                                     uint8 cmd, uint8 percentageValue,
   3585                                                                     uint8 disableDefaultRsp, uint8 seqNum )
   3586          {
   3587            uint8 buf[ZCL_WC_GOTOPERCENTAGEREQ_PAYLOADLEN];
   3588          
   3589            buf[0] = percentageValue;
   3590          
   3591            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING,
   3592                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   3593                                    disableDefaultRsp, 0, seqNum,
   3594                                    ZCL_WC_GOTOPERCENTAGEREQ_PAYLOADLEN, buf );
   3595          }
   3596          #endif //ZCL_WINDOWCOVERING
   3597          
   3598          /********************************************************************************************
   3599          *********************************************************************************************/

Errors: 3
Warnings: none
